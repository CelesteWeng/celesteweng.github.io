<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>Vue_造轮子（一）</title>
      <link href="/2019/04/11/Vue-%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%88%E4%B8%80%EF%BC%89/"/>
      <url>/2019/04/11/Vue-%E9%80%A0%E8%BD%AE%E5%AD%90%EF%BC%88%E4%B8%80%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="简易-UI-框架"><a href="#简易-UI-框架" class="headerlink" title="简易 UI 框架"></a>简易 UI 框架</h1><h2 id="课外资料"><a href="#课外资料" class="headerlink" title="课外资料"></a>课外资料</h2><ol><li><p>UI</p><ul><li><a href="https://framework7.io/docs/button.html" target="_blank" rel="noopener">Framework7</a></li><li><a href="https://ant.design/docs/react/introduce-cn" target="_blank" rel="noopener">Ant Design</a></li><li><a href="http://element.eleme.io/#/zh-CN/component/installation" target="_blank" rel="noopener">Element UI</a></li><li><a href="https://www.iviewui.com/docs/guide/install" target="_blank" rel="noopener">iView</a></li></ul></li><li><p>设计</p><ul><li>《写给大家看的设计书》</li><li><a href="Sketch中文网">Sketch中文网</a></li></ul></li><li><p>ES 6</p><ul><li><a href="https://frankfang.github.io/es-6-tutorials/" target="_blank" rel="noopener">ES 6 新特性列表及教程</a></li><li><a href="https://xiedaimala.com/courses/12a78a03-35f9-42ea-9b37-540540460f6e#/common" target="_blank" rel="noopener">《ES6 深入浅出》课程</a></li></ul></li><li><p>配色网站推荐</p><ul><li><a href="https://colorhunt.co/" target="_blank" rel="noopener">https://colorhunt.co/</a></li><li><a href="https://color.adobe.com/explore/" target="_blank" rel="noopener">https://color.adobe.com/explore/</a></li><li><a href="https://www.materialpalette.com/" target="_blank" rel="noopener">https://www.materialpalette.com/</a></li></ul></li><li><p>Windows 上像 Sketch 一样的工具 <a href="https://www.adobe.com/cn/products/xd.html" target="_blank" rel="noopener">https://www.adobe.com/cn/products/xd.html</a></p></li></ol><h2 id="构建流程"><a href="#构建流程" class="headerlink" title="构建流程"></a>构建流程</h2><ol><li>本地创建目录</li><li>创建仓库（e.t. github, gitlab）</li><li><p>相关命令：本地初始化仓库、npm、安装 parcel，不要忘记 <code>.gitignore</code>。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">touch README.md</span><br><span class="line">git init</span><br><span class="line">git add .</span><br><span class="line">git re..... // 直接复制就行</span><br><span class="line"></span><br><span class="line">npm init</span><br><span class="line"></span><br><span class="line">npm i -D parcel-bundler</span><br><span class="line"></span><br><span class="line">// ./node_modules/.bin/parcel index.html --no-cache</span><br><span class="line"></span><br><span class="line">npx parcel index.html --no-cache</span><br></pre></td></tr></table></figure></li><li><p>用 Vue.js 需要在 package.json 中配置</p></li><li><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&quot;alias&quot;: &#123;</span><br><span class="line">  &quot;vue&quot; : &quot;./node_modules/vue/dist/vue.common.js&quot;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>parcel<br>i. 创建 src 目录，将 JS 放入该目录<br>ii. 修改代码</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// path: 'ProjectName/src/app.js'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> Vue <span class="keyword">from</span> <span class="string">'vue'</span></span><br><span class="line"><span class="keyword">import</span> Button <span class="keyword">from</span> <span class="string">'./button'</span></span><br><span class="line"></span><br><span class="line">Vue.component(<span class="string">'g-button'</span>, Button)</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> Vue(&#123;</span><br><span class="line">    el: <span class="string">'#app'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">// path: &apos;ProjectName/src/button.vue&apos;</span><br><span class="line"></span><br><span class="line">&lt;template&gt;</span><br><span class="line">  &lt;button class=&quot;g-button&quot;&gt;按钮&lt;/button&gt;</span><br><span class="line">&lt;/template&gt;</span><br><span class="line">&lt;script&gt;</span><br><span class="line">    export default &#123;&#125;</span><br><span class="line">&lt;/script&gt;</span><br><span class="line">&lt;style lang=&quot;scss&quot;&gt;</span><br><span class="line">    .g-button &#123;</span><br><span class="line">        font-size: var(--font-size);</span><br><span class="line">        height: var(--button-height);</span><br><span class="line">        padding: 0 1em;</span><br><span class="line">        border-radius: var(--border-radius);</span><br><span class="line">        border: 1px solid var(--border-color);</span><br><span class="line">        background: var(--button-bg);</span><br><span class="line">        &amp;:hover &#123;</span><br><span class="line">            border-color: var(--border-color-hover);</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;:active &#123;</span><br><span class="line">            background-color: var(--button-active-bg);</span><br><span class="line">        &#125;</span><br><span class="line">        &amp;:focus &#123;</span><br><span class="line">            outline: none;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&lt;/style&gt;</span><br></pre></td></tr></table></figure></li></ol><h2 id="提交"><a href="#提交" class="headerlink" title="提交"></a>提交</h2><p>查看提交历史</p><ol><li>安装 <code>npm i -g git-open</code></li><li>在目录运行 <code>git open</code>，直接打开 github 对应页面</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> 相关资料 </tag>
            
            <tag> 构建项目流程 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>自用快捷键整理 + 收藏分享</title>
      <link href="/2019/04/05/%E8%87%AA%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/"/>
      <url>/2019/04/05/%E8%87%AA%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%94%AE%E6%95%B4%E7%90%86/</url>
      
        <content type="html"><![CDATA[<p>// 慢慢整吧，表示只想试试音乐？ Higher Brothers 好棒啊啊啊啊</p><a id="more"></a>  <!-- -    name: Paris in the Rain    artist: Lauv    url: "//music.163.com/song/media/outer/url?id=518904648.mp3"    cover: "//p2.music.126.net/4Xf4fRbDc2N30rShLT_irQ==/18251893021647481.jpg?param=130y130"  -    name: Pretty Thoughts (FKJ Remix)    artist: Alina Baraz / Galimatias / FKJ    url: "//music.163.com/song/media/outer/url?id=33887884.mp3"    cover: "//p2.music.126.net/xLHErjxKvfeTm7IgexHTSg==/3374401185910146.jpg?param=130y130"  -    name: 暴风雨    artist: Higher Brothers / HARIKIRI    url: "//music.163.com/song/media/outer/url?id=536622918.mp3"    cover: "//p1.music.126.net/IJ6knfb-NsIRYZJjGRDecA==/109951163165736088.jpg?param=130y130"  -    name: Shot Clock    artist: Ella Mai    url: "//music.163.com/song/media/outer/url?id=1317379864.mp3"    cover: "//p1.music.126.net/OG6eJJywZxchjCGVYOAcJg==/109951163909529203.jpg?param=130y130"  -    name: Emoji    artist: Galantis    url: "//music.163.com/song/media/outer/url?id=1321905583.mp3"    cover: "//p1.music.126.net/WqXhXI28Yhcv0uyQeG73uw==/109951163799327510.jpg?param=130y130" --><h2 id="mac-快捷键"><a href="#mac-快捷键" class="headerlink" title="mac 快捷键"></a>mac 快捷键</h2><ol><li>隐藏和最小化所有窗口：⌥⌘HM（当前窗口 隐藏/最小化：⌘H，⌘M）</li><li>表情：⌃⌘ 空格键</li><li>程序坞 Dock：⌥⌘D</li><li>启动台 Application: ⌥⌘A</li><li>不用鼠标操作：<ol><li>Tab 焦点</li><li>空格键 确定</li><li>PageDown：⌥↓</li><li>在窗口间移动焦点：⌃F4</li><li>鼠标键：⌥ ⌘ F5</li><li>打开文件/进入目录：⌘↓</li><li>Finder 中返回上一级：⌘↑</li></ol></li><li>全屏：⌃⌘F</li></ol><h2 id="IntelliJ-IDEA-Keybindings"><a href="#IntelliJ-IDEA-Keybindings" class="headerlink" title="IntelliJ IDEA Keybindings"></a>IntelliJ IDEA Keybindings</h2><ul><li><p>其他</p><ol><li>自动格式化：⌘ + ⌥ + L</li><li>最近打开的文件：⌘ + E</li><li>vscode 用TAB移动焦点：⌃ + ⇧ + M</li><li>vscode 终端窗口： ⌘ + ⇧ + M</li><li>搜索任何地方：⇧⇧（version control system - vcs）</li><li>代码报错改头大了，查看历史：VCS - Local History - Show History</li><li>设置：⌘ + ,</li></ol></li><li><p>跳转</p><ol><li>跳转到某行：⌘ + L</li><li>跳转到最后的编辑位置：⌘ + ⇧ + ⌫</li><li>跳转到定义的方法：⌃ + ⇧ + B</li><li>跳转到父级方法/父类：⌘ + U（super-method / super-class）</li></ol></li><li><p>设置</p><ol><li>字体缩放（自定义）：⌃ + ⌘ + -/=</li><li>窗口不够时文字是否换行：⌥ + Z</li></ol></li><li><p>删</p><ol><li>删除光标到行尾（光标在行尾时，合并行）：⌃ + K</li><li>webstorm 删除到单词前：⌥ + ⌫</li><li>删除到单词后：⌥⌦（fn + ⌥ + delete）</li><li>vscode 往回删除(delete left)：⌃ + H</li></ol></li><li><p>增</p><ol><li>往后新增一行：⇧ + ↩︎</li><li>往前新增一行：⌥ + ⌘ + ↩︎</li><li>完成当前行：⇧ + ⌘ + ↩︎</li><li>一行分割为多行：⌘ + ↩︎</li><li>下面增加一行空白行：⌃ + O（VSCode）</li></ol></li><li><p>改</p><ol><li>交换单词：⌃ + T（VSCode）</li><li>大小写切换：⇧ + ⌘ + U（uppercase）</li></ol></li><li><p>选中</p><ol><li>选中下一个和当前高亮内容相同的部分（addSelectionToNextFindMatch）: ⌃ + G (不是G就是D，sublime 是 D，vscode 默认 D)</li><li>选中所有和当前高亮内容相同的部分（selectHighlights）: ⌃ + ⌘ + G</li><li>多行光标：⌘ + ⌥ + ↑/↓</li><li>列选择模式开关（开启后拖动鼠标 or 按住⇧再按↓/↑，和多行光标的效果一样）：⇧⌘8</li><li>选中光标所在单词：⌃ + G</li><li>选择到代码块的 结尾/开头：⌘ + ⇧ + ]/[</li></ol></li><li><p>移动光标</p><ol><li>光标到行首：⌃ + A</li><li>光标到行尾：⌃ + E</li><li>光标后移：⌃ + F(forward)</li><li>光标前移：⌃ + B (back)</li><li>光标上移一行：⌃ + P（previous）</li><li>光标下移一行：⌃ + N（next）</li><li>光标到代码块 开始 位置：⌥ + ⌘ + [</li><li>光标到代码块 结束 位置：⌥ + ⌘ + ]</li></ol></li><li><p>git</p><ol><li>commit：⌘K</li></ol></li></ul><h3 id="常用"><a href="#常用" class="headerlink" title="常用"></a>常用</h3><ol><li>自动格式化：⌘ + ⌥ + L</li><li>最近打开的文件：⌘ + E</li><li>搜索任何地方：⇧⇧</li><li>字体缩放（自定义）：⌃ + ⌘ + -/=</li><li>往后新增一行：⇧ + ↩︎</li><li>选中下一个和当前高亮内容相同的部分（addSelectionToNextFindMatch）: ⌃ + G (不是G就是D，sublime 是 D，vscode 默认 D)</li><li>选中所有和当前高亮内容相同的部分（selectHighlights）: ⌃ + ⌘ + G</li><li>多行光标：⌘ + ⌥ + ↑/↓ （编辑完成后，按 Eec 光标变回1个，不然要鼠标去点一下）</li></ol><h4 id="感觉不会忘记没有记录，所以这里是最常用"><a href="#感觉不会忘记没有记录，所以这里是最常用" class="headerlink" title="感觉不会忘记没有记录，所以这里是最常用"></a>感觉不会忘记没有记录，所以这里是最常用</h4><ol><li>显示隐藏 side bar：⌘ + 1</li><li>移动光标（在原有按键上加上 ⇧ 则同时选中）：<ul><li>以单词为单位移动：alt + ← / →</li><li>移动到行首/行尾：⌘ + ← / →</li><li>文档开始/结束：⌘ + ↑ / ↓ （webStorm 中默认是修改焦点的，自己改下）</li></ul></li><li>打开多个文件时，往 左/右 查看文件：⌃ + ← / →</li><li>向 下/上 选中多行：⇧ + ↓ / ↑</li><li>将选中的内容 上/下 移一行：⇧ + ⌥ + ↓ / ↑</li><li>复制光标所在行内容到下一行（选中的多行内容也适用）：⌘D</li><li>复制一行内容到粘贴板不用选中一行，直接 ⌘C 就会复制光标所在行</li><li>删除当前行 / 删除选中的多行：⌘⌫</li><li>F你懂的：⇧⌘F</li><li>webStorm 中，<code>consolo.log(xxx)</code>，输入 <code>xxx.log</code> + Tab 即可</li></ol><p>整理的只有我用过的，以上不能满足需求时，特别全的：<a href="https://xu3352.github.io/ide/2017/07/03/intellij-idea-hotkey-reference-card" target="_blank" rel="noopener">https://xu3352.github.io/ide/2017/07/03/intellij-idea-hotkey-reference-card</a></p><h2 id="Markdown-all-in-one-shortcuts"><a href="#Markdown-all-in-one-shortcuts" class="headerlink" title="Markdown all in one shortcuts"></a>Markdown all in one shortcuts</h2><p>表格格式化：ALT + SHIFT + F;（就这个有点卵用）</p><h2 id="Chrome"><a href="#Chrome" class="headerlink" title="Chrome"></a>Chrome</h2><h3 id="点击链接时"><a href="#点击链接时" class="headerlink" title="点击链接时"></a>点击链接时</h3><ol><li>⌃ + click：右键;</li><li>⇧ + click：从新窗口打开链接;</li><li>⌘ + click：从新标签打开链接，但是当前查看标签不变;</li><li>⇧ + ⌘ + click：从新标签打开链接，当前查看标签变为新标签;</li><li>无聊试验发现，⌥ + click：下载链接对应的html。</li></ol><h3 id="常用-1"><a href="#常用-1" class="headerlink" title="常用"></a>常用</h3><ol><li>查看第几个标签：⌘ + 数字</li><li>向 左/右 查看标签：⌘⌥ + ← / → （或者 ⇧ + ⌃ + Tab 向左 / ⌃ + Tab 向右）</li><li>刷新：⌘R(refresh)</li><li>焦点移动到地址栏：⌘L(location)</li><li>添加到收藏夹：⌘D</li><li>显示/隐藏 收藏夹：⇧⌘B（bookmarks）</li><li>新标签：⌘T（tab）</li><li>打开刚才关闭的标签：⇧⌘T</li><li>新窗口：⌘N（new）</li><li>干坏事专用：⇧⌘N（您已进入无痕模式）</li><li>前进：⌘→ （或者 ⌘]）</li><li>后退：⌘← （或者 ⌘[）</li><li>自己试～ ⌥⌘I / ⌥⌘J / ⇧⌘c</li></ol><p>// 括号里的单词自己脑补的，有可能错的hehe</p><h2 id="收藏分享"><a href="#收藏分享" class="headerlink" title="收藏分享"></a>收藏分享</h2><ol><li><a href="https://www.w3cplus.com/css/advanced-css-form-styling.html" target="_blank" rel="noopener">美化表单的CSS高级技巧</a></li><li><a href="https://www.zhihu.com/question/20790576" target="_blank" rel="noopener">大公司里怎样开发和部署前端代码？</a></li><li><a href="http://www.cnblogs.com/cookiehu/p/5069900.html" target="_blank" rel="noopener">毫秒必争，前端网页性能最佳实践</a></li><li><a href="https://github.com/joyqi/mobile-device-js/blob/master/device.js" target="_blank" rel="noopener">mobile-device-js</a>（万一用得上呢）</li><li><a href="https://www.ui.cn/detail/70262.html" target="_blank" rel="noopener">65个免费下载的HTML5+CSS3登陆表单</a></li><li><a href="https://chon.io/blog/safari-ios-iphone-itouch-web-dev-inspector/" target="_blank" rel="noopener">Safari 前端开发调试 iOS 完美解决方案（iPhone/iTouch 等）</a>（电脑改代码，手机看效果）</li><li><a href="https://segmentfault.com/a/1190000010157682" target="_blank" rel="noopener">思路清奇：通过 JavaScript 获取移动设备的型号</a></li><li><a href="http://tool.oschina.net/" target="_blank" rel="noopener">在线工具导航</a></li><li><a href="https://www.cnblogs.com/zhaoqingqing/p/6902113.html" target="_blank" rel="noopener">快速启动神器 Wox</a></li><li><a href="https://zhuanlan.zhihu.com/p/31256701" target="_blank" rel="noopener">我不知道你知不知道的伪元素实用小技巧</a></li><li><a href="https://www.jianshu.com/u/c9f16aaefd6c" target="_blank" rel="noopener">如何优雅地使用Mac</a></li><li><a href="https://www.jianshu.com/p/b25c5b88baf5" target="_blank" rel="noopener">前端chrome浏览器调试总结</a></li><li><a href="http://www.cnblogs.com/coco1s/p/7519460.html" target="_blank" rel="noopener">你所不知道的 CSS 滤镜技巧与细节</a></li><li><a href="https://blog.crimx.com/2016/05/12/understanding-this/" target="_blank" rel="noopener">JavaScript This 的六道坎</a></li><li><a href="https://zhuanlan.zhihu.com/p/28645609" target="_blank" rel="noopener">几种 JavaScript 动画库推荐</a></li><li><a href="https://www.typingclub.com/sportal/program-3.game" target="_blank" rel="noopener">typingclub</a>（练指法挺好的）</li></ol><h2 id="Books"><a href="#Books" class="headerlink" title="Books"></a>Books</h2><p>链接: <a href="https://pan.baidu.com/s/13ROcS7YoD7xUoRaH57Ir4g" target="_blank" rel="noopener">https://pan.baidu.com/s/13ROcS7YoD7xUoRaH57Ir4g</a> 提取码: iqbe</p><h2 id="Others"><a href="#Others" class="headerlink" title="Others"></a>Others</h2><p>再推荐一个chrome的扩展程序吧，看到好的文章想收藏时，可以添加到收藏夹，但是网址有可能会失效。这时候可以选择保存网页剪报。</p><ol><li><a href="https://chrome.google.com/webstore/detail/evernote-web-clipper/pioclpoplcdbaefihamjohnefbikjilc?hl=zh-CN" target="_blank" rel="noopener">印象笔记</a></li><li><a href="https://chrome.google.com/webstore/detail/%E6%9C%89%E9%81%93%E4%BA%91%E7%AC%94%E8%AE%B0%E7%BD%91%E9%A1%B5%E5%89%AA%E6%8A%A5/joinpgckiioeklibflapokicmndlcnef?hl=zh-CN" target="_blank" rel="noopener">有道云笔记</a></li></ol><p>软件：Postman 调试接口</p>]]></content>
      
      
      
        <tags>
            
            <tag> 快捷键 </tag>
            
            <tag> Mac </tag>
            
            <tag> IntelliJ IDEA </tag>
            
            <tag> Plugin </tag>
            
            <tag> 收藏分享 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据_Cookie_Session_LocalStorage_Cache-Control</title>
      <link href="/2019/04/05/%E6%95%B0%E6%8D%AE-Cookie-Session-LocalStorage-Cache-Control/"/>
      <url>/2019/04/05/%E6%95%B0%E6%8D%AE-Cookie-Session-LocalStorage-Cache-Control/</url>
      
        <content type="html"><![CDATA[<h1 id="Cookie"><a href="#Cookie" class="headerlink" title="Cookie"></a>Cookie</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol><li>服务器通过 Set-Cookie 响应头设置 Cookie</li><li>浏览器得到 Cookie 之后，每次请求都要带上 Cookie</li><li>服务器读取 Cookie 就知道登陆用户的信息</li></ol><h2 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h2><ol><li><p>在 Chrome 上登陆得到了 Cookie，用 Safari 访问，Safari 会带上 Cookie 吗？</p><p> 答：不会，Cookie 是跟着浏览器的。</p></li><li><p>Cookie 存在哪？</p><p> 答：Windows 存在 C 盘的一个文件里，其他系统存在硬盘的某个文件中，你找不到，系统不让你改。</p></li><li><p>Cookie 可以作假吗？</p><p> 答：可以。Chrome 调试工具里就可以改。设置 HttpOnly 后，将不能用 JS 修改该 Cookie。</p></li><li><p>Cookie 的有效期是多久？</p><p> 答：20分钟左右，由浏览器决定。</p></li></ol><h2 id="LocalStorage"><a href="#LocalStorage" class="headerlink" title="LocalStorage"></a>LocalStorage</h2><p>session 是服务器上的 hash 表。<br>session 占内存，cookie 不占内存。<br>localStorage 是浏览器上的 hash 表。</p><p>localStorage.setItem(‘object’, { name: ‘obj’ })<br>在存储时会转化为字符串，而对象 toString 都会变成 “[object Object]”</p><p>正确：<br>localStorage.setItem(‘jsonString’, JSON.stringify({ name: ‘obj’ }))<br>localStorage.getItem<br>localStorage.clear()</p><p>localStorage 持久化存储，存在 C 盘文件中（windows系统）</p><p>问题：</p><ol><li><p>Cookie 和 Session 有什么关系？</p><p> 答：一般来说，Session 是基于 Cookie 来实现的，因为 SessionId（随机数）通过 Cookie 发给客户端。</p></li><li><p>Cookie 和 LocalStorage 最大的区别是什么？</p><p> 答：Cookie（4K） 会通过浏览器被带到服务器上去，HTTP 不会带上 LocalStorage（5Mb） 的值。</p></li><li><p>LocalStorage 和 SessionStorage 的区别？</p><p> 答：SessionStorage 在用户关闭页面（会话结束）后就失效。</p></li><li><p>Cookie 和 SessionStorage 的区别？</p><p> 答：都是在用户关闭页面后就失效，但是后台代码可以任意设置 Cookie 的过期时间。</p></li></ol><h2 id="不基于-Cookie-的-Session"><a href="#不基于-Cookie-的-Session" class="headerlink" title="不基于 Cookie 的 Session"></a>不基于 Cookie 的 Session</h2><ul><li>通过查询参数和 LocalStorage 传递 sessionId</li></ul><h2 id="前端永远不要-读-写-Cookie，用-LocalStorage"><a href="#前端永远不要-读-写-Cookie，用-LocalStorage" class="headerlink" title="前端永远不要 读/写 Cookie，用 LocalStorage"></a>前端永远不要 读/写 Cookie，用 LocalStorage</h2>]]></content>
      
      
      
        <tags>
            
            <tag> Cookie </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS题目总结（原型链、new、JSON、MVC、Promise）</title>
      <link href="/2019/03/19/JS%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81new%E3%80%81JSON%E3%80%81MVC%E3%80%81Promise%EF%BC%89/"/>
      <url>/2019/03/19/JS%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81new%E3%80%81JSON%E3%80%81MVC%E3%80%81Promise%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<a id="more"></a><h2 id="第一题"><a href="#第一题" class="headerlink" title="第一题"></a>第一题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> object = &#123;&#125;</span><br><span class="line">object.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">fn.__proto__ === <span class="built_in">Function</span>.prototype  <span class="comment">// 为 true</span></span><br><span class="line">fn.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> array = []</span><br><span class="line">array.__proto__ === <span class="built_in">Array</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line">array.__proto__.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"><span class="built_in">Array</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"><span class="built_in">Object</span>.__proto__ === <span class="built_in">Function</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="literal">true</span>.__proto__ === <span class="built_in">Boolean</span>.prototype <span class="comment">// 为 true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Function</span>.prototype.__proto__ === <span class="built_in">Object</span>.prototype <span class="comment">// 为 true</span></span><br></pre></td></tr></table></figure><h2 id="第二题"><a href="#第二题" class="headerlink" title="第二题"></a>第二题</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">new</span> fn()</span><br></pre></td></tr></table></figure><p>new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？</p><p>答：this 为构造函数 fn 的一个实例，有内置属性 <code>[[Prototype]]</code>，在部分浏览器中表现为 <code>__proto__</code> 属性；<br><code>this.__proto__ === fn.prototype // true</code>，this 的原型的属性有 <code>constructor</code>、<code>__proto__</code>。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 换成这样做</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> f1 = <span class="keyword">new</span> fn()</span><br><span class="line"><span class="built_in">console</span>.log(<span class="string">'(f1.__proto__ === fn.prototype) =&gt;'</span>, f1.__proto__ === fn.prototype)</span><br><span class="line"><span class="built_in">console</span>.log(f1)</span><br><span class="line"><span class="built_in">console</span>.log(f1.__proto__)</span><br></pre></td></tr></table></figure><h2 id="第三题"><a href="#第三题" class="headerlink" title="第三题"></a>第三题</h2><p>JSON vs JS =&gt; 博客-发送请求.md</p><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2><ol><li><p>前端 MVC 是什么？</p><p>答：MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller)</p><p><strong>模型</strong>：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作.</p><p><strong>视图</strong>：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。</p><p><strong>控制器</strong>：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。</p></li><li><p>请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">View('.xxx')</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.View = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Model(&#123;</span></span><br><span class="line"><span class="comment">  'resourceName': xxx</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.Model = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceName = object.resourceName</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fetch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        save: <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Controller(&#123;</span></span><br><span class="line"><span class="comment">    init: function(view, model) &#123;</span></span><br><span class="line"><span class="comment">        this.view = xxx</span></span><br><span class="line"><span class="comment">        this.model = xxx</span></span><br><span class="line"><span class="comment">        this.xxx()</span></span><br><span class="line"><span class="comment">        this.yyy()</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    <span class="doctag">xxx:</span> function() &#123;&#125;,</span></span><br><span class="line"><span class="comment">    yyy: function() &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.Controller = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> init = options.init</span><br><span class="line">    <span class="keyword">let</span> object = &#123;</span><br><span class="line">        view: <span class="literal">null</span>,</span><br><span class="line">        model: <span class="literal">null</span>,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">view, model</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.view = view</span><br><span class="line">            <span class="keyword">this</span>.model = model</span><br><span class="line">            <span class="keyword">this</span>.model.init()</span><br><span class="line">            init.call(<span class="keyword">this</span>, view, model)</span><br><span class="line">            <span class="comment">// this.bindEvents.call(this)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">'init'</span>) &#123;</span><br><span class="line">            object[key] = options[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="第五题"><a href="#第五题" class="headerlink" title="第五题"></a>第五题</h2><p>如何在 ES5 中如何用函数模拟一个类？（10分）</p><p>答：使用原型对象，构造函数，new来模拟类。</p><p>将公共属性放到原型对象里，并且将构造函数的prototype属性指向原型对象。<br>私有属性(自有属性)放到构造函数里去定义。<br>将实例化的对象的<strong>proto</strong>指向原型对象。<br>这样当构造函数创建一个实例化的对象的时候，就即拥有自己的私有变量和方法，也有公有的变量和方法了，实例化出来的对象的私有方法和变量修改都不会互相有影响，只有在修改公有的变量和方法的时候是对所有实例生效的。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Dessert</span>(<span class="params">name</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name</span><br><span class="line">&#125;</span><br><span class="line">Dessert.prototype.calorie = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line"><span class="keyword">let</span> dessert = <span class="keyword">new</span> Dessert(<span class="string">'iceCream'</span>)</span><br></pre></td></tr></table></figure><p>上面代码就是一个最简单的类，Dessert 构造函数创建出来的对象自身有 name 属性，其原型上面有一个 calorie 属性。</p><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><p>用过 Promise 吗？举例说明。<br>如果要你创建一个返回 Promise 对象的函数，你会怎么写？举例说明。</p><p>答：用过，调用后端接口对获取到的数据进行处理、自己模仿 jQuery 封装 Ajax、MVC 中 Model 的 fetch 属性和 save 属性返回 Promise 对象；</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* yyy().then(successFn, failFn)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">yyy</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (success) &#123;</span><br><span class="line">           resolve.call(<span class="literal">undefined</span>, ...zzz)</span><br><span class="line">        &#125; </span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (fail) &#123;</span><br><span class="line">           reject.call(<span class="literal">undefined</span>, ...qqq)</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
            <tag> new </tag>
            
            <tag> JSON </tag>
            
            <tag> MVC </tag>
            
            <tag> Promise </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无分类笔记-2（逻辑与或、命名空间、this、new、异步）</title>
      <link href="/2019/03/18/%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0-2%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%E6%88%96%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81this%E3%80%81new%EF%BC%89/"/>
      <url>/2019/03/18/%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0-2%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%E6%88%96%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81this%E3%80%81new%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h1 id="面相对象编程吧"><a href="#面相对象编程吧" class="headerlink" title="面相对象编程吧"></a>面相对象编程吧</h1><h2 id="逻辑与或"><a href="#逻辑与或" class="headerlink" title="逻辑与或"></a>逻辑与或</h2><h3 id="amp-amp"><a href="#amp-amp" class="headerlink" title="&amp;&amp;"></a>&amp;&amp;</h3><p>有假的，返回第一个 falsy 值，遇到 falsy 值就不往后判断了；全是真的，返回最后一个 truy 值。</p><p>falsy值：<code>0</code>、<code>NaN</code>、<code>null</code>、<code>undefined</code>、<code>&quot;&quot;</code>、<code>false</code>.</p><h3 id><a href="#" class="headerlink" title="||"></a>||</h3><p>有真的，返回第一个 truy 值，遇到 truy 值就中断；全是假的，返回最后一个 falsy 值。</p><h2 id="命名空间"><a href="#命名空间" class="headerlink" title="命名空间"></a>命名空间</h2><p>命名空间（Namespace），也称名称空间等，它表示着一个标识符（identifier）的可见范围。 一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。</p><p>(e.g., window.jQuery、电脑中的文件夹)</p><h2 id="this"><a href="#this" class="headerlink" title="this"></a>this</h2><p><code>element.onclick = functionRef;</code></p><p>在函数内，this 是触发当前事件的元素。</p><h2 id="new"><a href="#new" class="headerlink" title="new"></a>new</h2><p><img src="http://pntmc1hcw.bkt.clouddn.com//blog/img/prototype.png" alt="prototype.png"><br><img src="http://pntmc1hcw.bkt.clouddn.com//blog/img/prototype-2.png" alt="prototype-2.png"></p><h2 id="异步、回调"><a href="#异步、回调" class="headerlink" title="异步、回调"></a>异步、回调</h2><p>异步：【不等结果】直接执行下一步。<br>如何拿到结果 =&gt; 回调可以拿到异步的结果</p><p>【回调是拿到异步结果的一种方式】<br>【回调也可以拿到同步结果】</p><ul><li>什么是回调</li></ul><p>在JavaScript中，函数是对象。因此，函数可以将函数作为参数，并且可以由其他函数返回。执行此操作的函数称为高阶函数。任何作为参数传递的函数都称为回调函数。</p><p>简而言之，回调是一个在另一个函数完成执行后执行的函数。</p><p>回调是拿到异步结果的一种方式，同时回调也可以拿到同步结果。</p>]]></content>
      
      
      
        <tags>
            
            <tag> new </tag>
            
            <tag> 逻辑与或 </tag>
            
            <tag> 命名空间 </tag>
            
            <tag> this </tag>
            
            <tag> 异步、回调 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>无分类笔记（解构赋值、立即执行函数、闭包、MVC、Promise）</title>
      <link href="/2019/03/16/%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%81%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81MVC%E3%80%81Promise%EF%BC%89/"/>
      <url>/2019/03/16/%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%81%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81MVC%E3%80%81Promise%EF%BC%89/</url>
      
        <content type="html"><![CDATA[<h4 id="ES6-解构赋值"><a href="#ES6-解构赋值" class="headerlink" title="ES6 解构赋值"></a>ES6 解构赋值</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> &#123; url, method, body &#125; = options</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><a id="more"></a><p>从作为函数实参的对象中提取数据</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 直接将第一个参数解构并声明，相当于用 let 声明</span></span><br><span class="line"><span class="keyword">var</span> fn = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;url, method, body&#125;</span>)</span>&#123;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>交换变量的值</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="string">'a'</span></span><br><span class="line"><span class="keyword">var</span> b = <span class="string">'b'</span></span><br><span class="line"></span><br><span class="line">[a, b] = [b, a]</span><br></pre></td></tr></table></figure><p>其余功能：加<code>()</code>免声明（要在语句前加<code>;</code>）、修改属性名、忽略某个值（用<code>,</code>分割，空出下标对应项）、<code>...rest</code>剩余项赋值给一个变量、设置默认值（等号左边用<code>=</code>，等号右边用<code>:</code>）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="noopener">解构赋值–MDN</a></p><h4 id="Promise-的意义"><a href="#Promise-的意义" class="headerlink" title="Promise 的意义"></a>Promise 的意义</h4><ol><li>不用取名字。不用去记参数名，直接在 <code>.then()</code>中写，第一个参数为成功的回调，第二个参数为失败的回调。</li><li><code>.then</code>可以对一个状态进行多次处理</li></ol><p><code>jQuery.ajax</code>中 responseText (“Content-Type”: “text/json”)，会自动转化为对象。</p><p>封装 jQuery.ajax</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span>(<span class="params">nodesOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123;&#125;</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  node.textContent = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">window</span>.$ = <span class="built_in">window</span>.jQuery</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123;url, method, headers, body, success, fail&#125;</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(method, url)</span><br><span class="line">  <span class="keyword">for</span>(<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">    <span class="keyword">let</span> value = headers[key]</span><br><span class="line">    request.setRequestHeader(key, value)</span><br><span class="line">  &#125;</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        success.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">        fail.call(<span class="literal">undefined</span>, request)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  request.send()</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSthIfSuccess</span>(<span class="params">responseText</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">myButton.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">  $.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/xxx'</span>,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-ype'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">      <span class="string">'Name'</span>: <span class="string">'Celeste'</span></span><br><span class="line">    &#125;,</span><br><span class="line">    success: <span class="function">(<span class="params">responseText</span>) =&gt;</span> &#123;</span><br><span class="line">      doSthIfSuccess.call(<span class="literal">undefined</span>, responseText)</span><br><span class="line">    &#125;,</span><br><span class="line">    fail: <span class="function">(<span class="params">response</span>) =&gt;</span> &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(response, response.status, response.responseText)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 自己封装 jQuery.ajax 满足 Promise 规则</span></span><br><span class="line"><span class="built_in">window</span>.jQuery.ajax = <span class="function"><span class="keyword">function</span>(<span class="params">&#123; url, method, body, headers &#125;</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">        request.open(method, url)</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> headers) &#123;</span><br><span class="line">            <span class="keyword">let</span> value = headers[key]</span><br><span class="line">            request.setRequestHeader(key, value)</span><br><span class="line">        &#125;</span><br><span class="line">        request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">            <span class="keyword">if</span> (request.readyState === <span class="number">4</span>) &#123;</span><br><span class="line">                <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">                    resolve.call(<span class="literal">undefined</span>, request.responseText)</span><br><span class="line">                &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">                    reject.call(<span class="literal">undefined</span>, request)</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            request.send()</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> promise = jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/xxx'</span>,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">      <span class="string">'Name'</span>: <span class="string">'Alice'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line"></span><br><span class="line">  promise.then(</span><br><span class="line">    (text) =&gt; &#123; <span class="built_in">console</span>.log(text) &#125;,</span><br><span class="line">    (request) =&gt; &#123; <span class="built_in">console</span>.log(request) &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 上述代码相当于</span></span><br><span class="line">myButton.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">  jQuery.ajax(&#123;</span><br><span class="line">    url: <span class="string">'/xxx'</span>,</span><br><span class="line">    method: <span class="string">'get'</span>,</span><br><span class="line">    headers: &#123;</span><br><span class="line">      <span class="string">'Content-Type'</span>: <span class="string">'application/x-www-form-urlencoded'</span>,</span><br><span class="line">      <span class="string">'Name'</span>: <span class="string">'Alice'</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;).then(</span><br><span class="line">    (text) =&gt; &#123; <span class="built_in">console</span>.log(text) &#125;,</span><br><span class="line">    (request) =&gt; &#123; <span class="built_in">console</span>.log(request) &#125;</span><br><span class="line">  )</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h4 id="如何使用立即执行函数"><a href="#如何使用立即执行函数" class="headerlink" title="如何使用立即执行函数"></a>如何使用立即执行函数</h4><ol><li>我们不想要全局变量</li><li>我们要使用局部变量</li><li>ES 5 里面，只有函数有局部变量</li><li>于是我们声明一个 function xxx，然后 xxx.call()</li><li>这个时候 xxx 是全局变量（全局函数）</li><li>所以我们不能给这个函数名字</li><li>function(){}.call()</li><li>但是 Chrome 报错，语法错误</li><li>试出来一种方法可以不报错:<br>i. !function(){}.call() (我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系)<br>ii. (function(){}).call() 方方不推荐<br>   xxx<br>   (function(){}).call() 报错<br>iii. frank192837192463981273912873098127912378.call() 不推荐</li></ol><h4 id="如何使用闭包"><a href="#如何使用闭包" class="headerlink" title="如何使用闭包"></a>如何使用闭包</h4><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span>,</span><br><span class="line">    age: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">window</span>.personGrowUp = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person.age += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> person.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> accessor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; <span class="comment">// accessor 为 返回匿名函数 的 匿名函数</span></span><br><span class="line">  <span class="keyword">var</span> person = &#123;</span><br><span class="line">    name: <span class="string">'xiaoming'</span>,</span><br><span class="line">    age: <span class="number">3</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    person.age += <span class="number">1</span></span><br><span class="line">    <span class="keyword">return</span> person.age</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> growUp = accessor.call() <span class="comment">// growUp 为函数</span></span><br><span class="line"></span><br><span class="line">growUp.call()</span><br></pre></td></tr></table></figure><ol><li>立即执行函数使得 person 无法被外部访问</li><li>闭包使得匿名函数可以操作 person</li><li>window.frankGrowUp 保存了匿名函数的地址</li><li>任何地方都可以使用 window.frankGrowUp<br>=&gt; 任何地方都可以使用 window.frankGrowUp 操作 person，但是不能直接访问 person</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// MVC的M和V</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> view = <span class="built_in">document</span>.querySelector(<span class="string">'#topNavBar'</span>)</span><br><span class="line">  <span class="keyword">var</span> controller = <span class="function"><span class="keyword">function</span>(<span class="params">view</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">      <span class="comment">// ...  </span></span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  controller.call(<span class="literal">undefined</span>, view)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将 controller 变成对象</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> view = <span class="built_in">document</span>.querySelector(<span class="string">'#topNavBar'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> controller = &#123;</span><br><span class="line">    view: <span class="literal">null</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.view = view</span><br><span class="line">      <span class="keyword">this</span>.bindEvents()</span><br><span class="line">      <span class="comment">// this.bindEvents.call(this)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> view = <span class="keyword">this</span>.view</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          view.classList.add(<span class="string">'sticky'</span>)</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          view.classList.remove(<span class="string">'sticky'</span>)</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  controller.init(view)</span><br><span class="line">  <span class="comment">// controller.init.call(controller, view)</span></span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将对 view 的操作全部放在 controller 的属性内，使代码的结构变得清晰</span></span><br><span class="line">!<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> view = <span class="built_in">document</span>.querySelector(<span class="string">'#topNavBar'</span>)</span><br><span class="line"></span><br><span class="line">  <span class="keyword">var</span> controller = &#123;</span><br><span class="line">    view: <span class="literal">null</span>,</span><br><span class="line">    init: <span class="function"><span class="keyword">function</span>(<span class="params">view</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.view = view</span><br><span class="line">      <span class="keyword">this</span>.bindEvents()</span><br><span class="line">      <span class="comment">// this.bindEvents.call(this)</span></span><br><span class="line">    &#125;,</span><br><span class="line">    bindEvents: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> view = <span class="keyword">this</span>.view</span><br><span class="line">      <span class="built_in">window</span>.addEventListener(<span class="string">'scroll'</span>, (e) =&gt; &#123;</span><br><span class="line">        <span class="comment">// 1. 函数内 this 为触发事件的元素，使用 function()&#123;&#125; 需要绑定 this</span></span><br><span class="line">        <span class="comment">// function()&#123;&#125;.bind(this)</span></span><br><span class="line">        <span class="comment">// 2. 使用箭头函数。箭头函数没有 this，没有箭头函数的内外 this 是一样的</span></span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">window</span>.scrollY &gt; <span class="number">0</span>) &#123;</span><br><span class="line">          <span class="keyword">this</span>.active()</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">          <span class="keyword">this</span>.deactive()</span><br><span class="line">        &#125;</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;，</span><br><span class="line">    active: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.view.classList.add(<span class="string">'sticky'</span>)</span><br><span class="line">    &#125;,</span><br><span class="line">    deactive: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">this</span>.view.classList.remove(<span class="string">'sticky'</span>)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  controller.init(view)</span><br><span class="line">  <span class="comment">// controller.init.call(controller, view)</span></span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure><h4 id="MVC"><a href="#MVC" class="headerlink" title="MVC"></a>MVC</h4><p>MVC 是一种组织代码的思想，使代码结构更清晰，方便后续的修改的扩展。</p><p><img src="http://pntmc1hcw.bkt.clouddn.com//blog/img/MVC.png" alt="MVC.png"></p><p>MVC 将代码分成三块：</p><ol><li>控制器（Controller）- 负责转发请求，对请求进行处理（负责其他的所有事情）。</li><li>视图（View） - 界面设计人员进行图形界面设计（你的代码长什么样子或者你的代码在哪一块）。</li><li>模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)（一个操作数据的对象。初始化、获取和保存等）。</li></ol><p>Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View<br>用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View。</p><p>MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller);</p><p>  模型：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作.</p><p>  视图：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。</p><p>  控制器：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作;比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理; 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。</p><ol><li><p>前端 MVC 是什么？</p><p>答：MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller)</p><p><strong>模型</strong>：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作.</p><p><strong>视图</strong>：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。</p><p><strong>控制器</strong>：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。</p></li><li><p>请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。</p></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">View('.xxx')</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.View = <span class="function"><span class="keyword">function</span> (<span class="params">selector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">document</span>.querySelector(selector)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Model(&#123;</span></span><br><span class="line"><span class="comment">  'resourceName': xxx</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.Model = <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> resourceName = object.resourceName</span><br><span class="line">    <span class="keyword">return</span> &#123;</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        fetch: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">        save: <span class="function"><span class="keyword">function</span>(<span class="params">object</span>) </span>&#123;&#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">Controller(&#123;</span></span><br><span class="line"><span class="comment">    init: function(view, model) &#123;</span></span><br><span class="line"><span class="comment">        this.view = xxx</span></span><br><span class="line"><span class="comment">        this.model = xxx</span></span><br><span class="line"><span class="comment">        this.xxx()</span></span><br><span class="line"><span class="comment">        this.yyy()</span></span><br><span class="line"><span class="comment">    &#125;,</span></span><br><span class="line"><span class="comment">    <span class="doctag">xxx:</span> function() &#123;&#125;,</span></span><br><span class="line"><span class="comment">    yyy: function() &#123;&#125;</span></span><br><span class="line"><span class="comment">&#125;)</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="built_in">window</span>.Controller = <span class="function"><span class="keyword">function</span>(<span class="params">options</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> init = options.init</span><br><span class="line">    <span class="keyword">let</span> object = &#123;</span><br><span class="line">        view: <span class="literal">null</span>,</span><br><span class="line">        model: <span class="literal">null</span>,</span><br><span class="line">        init: <span class="function"><span class="keyword">function</span>(<span class="params">view, model</span>) </span>&#123;</span><br><span class="line">            <span class="keyword">this</span>.view = view</span><br><span class="line">            <span class="keyword">this</span>.model = model</span><br><span class="line">            <span class="keyword">this</span>.model.init()</span><br><span class="line">            init.call(<span class="keyword">this</span>, view, model)</span><br><span class="line">            <span class="comment">// this.bindEvents.call(this)</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">in</span> options) &#123;</span><br><span class="line">        <span class="keyword">if</span> (key !== <span class="string">'init'</span>) &#123;</span><br><span class="line">            object[key] = options[key]</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> object</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> MVC </tag>
            
            <tag> Promise </tag>
            
            <tag> 解构赋值 </tag>
            
            <tag> 使用立即执行函数 </tag>
            
            <tag> 使用闭包 </tag>
            
            <tag> 封装 jQuery.ajax </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>从输入URL到页面加载发生了什么</title>
      <link href="/2019/03/15/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/"/>
      <url>/2019/03/15/%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88/</url>
      
        <content type="html"><![CDATA[<h1 id="浏览器查找域名对应的-IP-地址"><a href="#浏览器查找域名对应的-IP-地址" class="headerlink" title="浏览器查找域名对应的 IP 地址"></a>浏览器查找域名对应的 IP 地址</h1><h2 id="概念解释"><a href="#概念解释" class="headerlink" title="概念解释"></a>概念解释</h2><ul><li>IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址；</li><li>域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 <a href="http://www.baidu.com（百度域名）" target="_blank" rel="noopener">www.baidu.com（百度域名）</a> 而不是 220.181.112.244（百度的其中一个 IP 地址）；</li><li>DNS（域名服务器）：每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。</li></ul><a id="more"></a><h2 id="查找过程"><a href="#查找过程" class="headerlink" title="查找过程"></a>查找过程</h2><p>以查询 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行</p><ol><li>浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）；</li><li>搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）；</li><li>操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求；<ol><li>LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址；</li><li>LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址；</li><li>LDNS 向 baidu.com 域名服务器发起请求，得到 <a href="http://www.baidu.com" target="_blank" rel="noopener">www.baidu.com</a> 的 IP 地址；</li></ol></li><li>LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来；</li><li>操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来；</li><li><p>至此，浏览器已经得到了域名对应的 IP 地址。</p><p><strong>补充</strong>：域名与 URL 是两个概念。IP 地址与域名不是一一对应的关系。</p></li></ol><h1 id="建立连接–三次握手"><a href="#建立连接–三次握手" class="headerlink" title="建立连接–三次握手"></a>建立连接–三次握手</h1><h2 id="历程"><a href="#历程" class="headerlink" title="历程"></a>历程</h2><ol><li>主机向服务器发送一个建立连接的请求（您好，我想认识您）；</li><li>服务器接到请求后发送同意连接的信号（好的，很高兴认识您）；</li><li><p>主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。</p><p><strong>补充</strong>：</p><ul><li><strong>TCP 协议</strong>：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。</li><li><strong>为什么要握手三次</strong>：确保 server 和 client 双方都能 发送请求 和 接收请求。</li></ul></li></ol><h1 id="网页请求与显示"><a href="#网页请求与显示" class="headerlink" title="网页请求与显示"></a>网页请求与显示</h1><p>当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。</p><ol><li>浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等；</li><li>服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件；</li><li>服务器将得到的 HTML 文件发送给浏览器；</li><li>在浏览器还没有完全接收 HTML 文件时便开始<a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">渲染</a>、显示网页；</li><li><p>在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ；</p><p><strong>补充</strong>：</p><ul><li>TCP 数据包的数据有大小限制（<strong>1400字节</strong>），一次性发送大量数据则分成多个包。TCP 协议为每个包编号（sequence number，SEQ）。第一个包的编号是<strong>随机数</strong>，下一个数据包的编号是 1号包编号+1号包字节数。</li></ul></li></ol><h1 id="断开连接–四次挥手"><a href="#断开连接–四次挥手" class="headerlink" title="断开连接–四次挥手"></a>断开连接–四次挥手</h1><ol><li>主机向服务器发送一个断开连接的请求（不早了，我该走了）；</li><li>服务器接到请求后发送确认收到请求的信号（知道了）；</li><li>服务器向主机发送断开通知（我也该走了）；</li><li><p>主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接；</p><p><strong>补充</strong>：</p><ul><li>为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。</li><li>第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。</li></ul></li></ol><hr><h1 id="资料"><a href="#资料" class="headerlink" title="资料"></a>资料</h1><ol><li><a href="http://www.ruanyifeng.com/blog/2015/09/web-page-performance-in-depth.html" target="_blank" rel="noopener">页面性能管理——阮一峰</a>（页面生成过程、性能优化等）</li><li><a href="https://zhuanlan.zhihu.com/p/29879682" target="_blank" rel="noopener">Chrome Devtool Performance 使用指南（译文）</a>（原timeline）</li><li><a href="http://www.ruanyifeng.com/blog/2014/09/illustration-ssl.html" target="_blank" rel="noopener">TLS/SSL握手过程——阮一峰</a></li><li>关于该问题的两篇博客：<br> <a href="https://zhuanlan.zhihu.com/p/23155051" target="_blank" rel="noopener">从输入URL到页面加载发生了什么 1</a>（这篇条理清晰，对于渲染略过了，可以结合第二篇、资料1）<br> <a href="https://segmentfault.com/a/1190000006879700" target="_blank" rel="noopener">从输入URL到页面加载发生了什么 2</a>（比上者更优之处：DNS 解析图、HTTP 请求）单词错误：repain =&gt; repaint<br> 关于 TCP 两篇都没怎么说，详见 资料6</li><li><a href="http://restlet.com/company/blog/2015/11/18/navigating-http-status-codes/" target="_blank" rel="noopener">浏览 HTTP 状态码（地铁地图）</a></li><li><a href="http://www.ruanyifeng.com/blog/2017/06/tcp-protocol.html" target="_blank" rel="noopener">TCP 协议简介——阮一峰</a></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> DNS 缓存 </tag>
            
            <tag> TCP </tag>
            
            <tag> 页面渲染 </tag>
            
            <tag> chrome performance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>发送请求</title>
      <link href="/2019/03/13/%E8%AF%B7%E6%B1%82/"/>
      <url>/2019/03/13/%E8%AF%B7%E6%B1%82/</url>
      
        <content type="html"><![CDATA[<p>资料：<a href="http://www.ruanyifeng.com/blog/2016/04/same-origin-policy.html" target="_blank" rel="noopener">浏览器同源政策及其规避方法</a></p><h1 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h1><ul><li>JSONP（JSON with Padding） 和 JSON 实际上没什么关系，传输的数据也可以为 string。</li><li>jQuery 将 JSONP 方法放在 <code>$.ajax</code> 下，实际上 JSONP 和 Ajax 也没啥关系。</li><li>为什么要用 JSONP ？<ul><li>用 <code>form</code> 表单提交会刷新页面</li><li>用 <code>image</code> 发起 GET 请求，不刷新页面，但是只能知道成功和失败，不能传输更多数据。</li><li>用 <code>scirpt</code>，后端无法知道前端要执行什么代码，耦合。</li><li><code>JSONP = script + callback</code>。用 script + callback 的形式，发送 GET 请求来实现服务器与客户端跨源通信。动态创建 <code>&lt;script&gt;</code> 标签，用 <code>callback</code> 来传递参数降低前后端代码的耦合。</li></ul></li></ul><a id="more"></a><h2 id="JSONP-为什么不支持-POST-请求"><a href="#JSONP-为什么不支持-POST-请求" class="headerlink" title="JSONP 为什么不支持 POST 请求"></a>JSONP 为什么不支持 POST 请求</h2><p>答：因为 JSONP 是通过动态创建 <code>&lt;script&gt;</code> 标签实现的，动态创建 scirpt 时只能用 GET，没办法 POST。</p><h1 id="AJAX"><a href="#AJAX" class="headerlink" title="AJAX"></a>AJAX</h1><h2 id="请使用原生JS来发送AJAX请求"><a href="#请使用原生JS来发送AJAX请求" class="headerlink" title="请使用原生JS来发送AJAX请求"></a>请使用原生JS来发送AJAX请求</h2><h2 id="JSON-VS-JS"><a href="#JSON-VS-JS" class="headerlink" title="JSON VS JS"></a>JSON VS JS</h2><ul><li><p>关系：JSON 是一门抄袭了 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）。</p></li><li><p>区别：JSON 的字符串首尾必须是 <code>&quot;</code>， 有 Object / Array / Number / String / Null / Boolean，没有 Funciton 和 Undefined，没有内置的 Date、Math、RegExp 等。</p></li></ul><table><thead><tr><th>JavaScript</th><th>JSON</th></tr></thead><tbody><tr><td>undefined</td><td>没有</td></tr><tr><td>null</td><td>null</td></tr><tr><td>[‘a’, ‘b’]</td><td>[“a”, “b”]</td></tr><tr><td>function fn(){}</td><td>没有</td></tr><tr><td>{name: ‘celeste’}</td><td>{“name”: “frank”}</td></tr><tr><td><code>var a = {}</code><br><code>a.self = a</code></td><td>搞不定（没有变量）</td></tr><tr><td><code>{__proto__}</code></td><td>没有原型链</td></tr></tbody></table><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">myButton.addEventListener(<span class="string">'click'</span>, (e) =&gt; &#123;</span><br><span class="line">  <span class="keyword">let</span> request = <span class="keyword">new</span> XMLHttpRequest()</span><br><span class="line">  request.open(<span class="string">'GET'</span>, <span class="string">'/xxx'</span>) <span class="comment">// 配置 request</span></span><br><span class="line">  request.send()</span><br><span class="line">  request.onreadystatechange = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (request.readystate === <span class="number">4</span>) &#123;</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'请求都响应完毕了'</span>)</span><br><span class="line"></span><br><span class="line">      <span class="keyword">if</span> (request.status &gt;= <span class="number">200</span> &amp;&amp; request.status &lt; <span class="number">300</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说明请求成功'</span>)</span><br><span class="line">        <span class="keyword">let</span> string = request.responseText</span><br><span class="line">        <span class="comment">// 把符合 JSON 语法的字符串</span></span><br><span class="line">        <span class="comment">// 转换成 JS 对应的值</span></span><br><span class="line">        <span class="keyword">let</span> object = <span class="built_in">JSON</span>.parse(string)</span><br><span class="line">        <span class="comment">// JSON.parse 是浏览器提供的</span></span><br><span class="line">      &#125; <span class="keyword">else</span> <span class="keyword">if</span> (request.status &gt;= <span class="number">400</span>) &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'说明请求失败'</span>)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure><h1 id="同源策略"><a href="#同源策略" class="headerlink" title="同源策略"></a>同源策略</h1><p>用表单发送 GET 请求，可以跨域。因为获取到响应后页面会刷新，浏览器认为这样是安全的。<br>用 AJAX 不能跨域。因为 AJAX 可以获取到响应内容，</p><p>浏览器必须保证<br>只有 协议+端口+域名 <code>一模一样</code>才允许发 AJAX 请求</p><h1 id="CORS-Cross-Origin-Resource-Sharing"><a href="#CORS-Cross-Origin-Resource-Sharing" class="headerlink" title="CORS(Cross-Origin Resource Sharing)"></a>CORS(Cross-Origin Resource Sharing)</h1><p>后台加一个响应头，最好每个接口分开处理，不要写成全局的。<br><code>response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://xxx.com:8000&#39;)</code></p><hr><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">GET /xxx HTTP/1.1</span><br><span class="line">HOST: jack.com:8002</span><br><span class="line">Content-type: application/x-www-form-url encoded</span><br></pre></td></tr></table></figure><ol><li><p>JS 可以设置任意请求 header 吗<br><code>XMLHttpRequest.setRequestHeader(header, value)</code>是设置HTTP请求头的方法。必须在 <code>open()</code> 和 <code>send()</code> 之间调用。多次对同一请求头赋值，只会生成一个合并了多个值的请求头。</p><p>第一部分 request.open(‘get’, ‘/xxx’)<br>第二部分 request.setHeader(‘Content-type’, ‘x-www-form-urlencoded’)<br>第四部分 request.send(‘a=1&amp;b=2’)</p></li><li><p>JS 设置请求体<br><code>myReq.send()</code></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">// xhr.send(&apos;string&apos;);</span><br><span class="line">// xhr.send(new Blob());</span><br><span class="line">// xhr.send(new Int8Array());</span><br><span class="line">// xhr.send(&#123; form: &apos;data&apos; &#125;);</span><br><span class="line">// xhr.send(document);</span><br></pre></td></tr></table></figure><p>第一部分 request.status / request.statusText<br>第二部分 request.getResponseHeader() / request.getAllResponseHeaders()<br>第四部分 request.responseText</p></li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> JSONP </tag>
            
            <tag> AJAX </tag>
            
            <tag> 同源策略 </tag>
            
            <tag> CORS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>jQuery体验</title>
      <link href="/2019/03/09/jQuery%E4%BD%93%E9%AA%8C/"/>
      <url>/2019/03/09/jQuery%E4%BD%93%E9%AA%8C/</url>
      
        <content type="html"><![CDATA[<h2 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = ???</span><br><span class="line"><span class="built_in">window</span>.$ = jQuery</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> $div = $(<span class="string">'div'</span>)</span><br><span class="line">$div.addClass(<span class="string">'red'</span>) <span class="comment">// 可将所有 div 的 class 添加一个 red</span></span><br><span class="line">$div.setText(<span class="string">'hi'</span>) <span class="comment">// 可将所有 div 的 textContent 变为 hi</span></span><br></pre></td></tr></table></figure><a id="more"></a><h2 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h2><h3 id="第一次、第二次"><a href="#第一次、第二次" class="headerlink" title="第一次、第二次"></a>第一次、第二次</h3><ol><li>传入的是字符串，直接用 DOM api 获取节点。</li><li>addClass：遍历 nodes，获取每个节点的 className，如果没有要添加的类，则添加。</li><li>setText：遍历 nodes，直接在每个节点写入 textContent。</li><li>一开始使用 for 循环遍历，querySelectorAll 获取到的为类数组对象，改成了 forEach 遍历，addClass、setText 函数内将 nodes 换成 this，感觉这样可以实现更松散的耦合。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span> (<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.forEach(<span class="function"><span class="params">t</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">if</span> (!t.className.split(<span class="string">' '</span>).includes(classes)) &#123;</span><br><span class="line">        t.classList.add(classes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;)</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.forEach(<span class="function"><span class="params">t</span> =&gt;</span> t.textContent = text)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第三次"><a href="#第三次" class="headerlink" title="第三次"></a>第三次</h3><ol><li>上述功能没有达到参数 nodeOrSelector 代表的含义，传入节点是不行的。</li><li>增加对 nodeOrSelector 的判断，分 string 和 node</li></ol><h3 id="第四次"><a href="#第四次" class="headerlink" title="第四次"></a>第四次</h3><ol><li>改完发现传入多个节点时是错误的，一个节点的部分原型链是这样的，<code>HTMLDivElement -&gt; HTMLElement -&gt; Element -&gt; Node</code>，多个节点的原型对象是 <code>HTMLCollection</code> 的实例，判断改成 string、Node 的实例或 HTMLCollection 的实例。</li><li><code>let nodes = {}</code> -&gt; <code>let nodes = { length: 0 }</code> 觉得既然是伪数组，那么一开始就要有 length 属性。</li><li>让节点的原型链纯净，只将需要的属性值赋给 nodes。</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment">// 传入字符串</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// 传入1个节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">    nodes = &#123; <span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125; </span><br><span class="line">  <span class="comment">// 传入多个节点</span></span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> HTMLCollection) &#123;</span><br><span class="line">    <span class="keyword">let</span> temp = nodeOrSelector</span><br><span class="line">    nodes.length = temp.length</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">      nodes[i] = temp[i]</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="第五次"><a href="#第五次" class="headerlink" title="第五次"></a>第五次</h3><ol><li>遍历代码重复了，累赘，封装成函数</li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.jQuery = <span class="function"><span class="keyword">function</span> (<span class="params">nodeOrSelector</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> nodes = &#123; <span class="attr">length</span>: <span class="number">0</span> &#125;</span><br><span class="line">  <span class="comment">// 传入1个节点</span></span><br><span class="line">  <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> Node) &#123;</span><br><span class="line">    nodes = &#123; <span class="number">0</span>: nodeOrSelector, <span class="attr">length</span>: <span class="number">1</span> &#125;</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">cloneObject</span>(<span class="params">nodes, temp</span>) </span>&#123;</span><br><span class="line">      nodes.length = temp.length</span><br><span class="line">      <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; temp.length; i++) &#123;</span><br><span class="line">        nodes[i] = temp[i]</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 传入字符串</span></span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">typeof</span> nodeOrSelector === <span class="string">'string'</span>) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = <span class="built_in">document</span>.querySelectorAll(nodeOrSelector)</span><br><span class="line">      cloneObject(nodes, temp)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 传入多个节点</span></span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (nodeOrSelector <span class="keyword">instanceof</span> HTMLCollection) &#123;</span><br><span class="line">      <span class="keyword">let</span> temp = nodeOrSelector</span><br><span class="line">      cloneObject(nodes, temp)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  nodes.addClass = <span class="function"><span class="keyword">function</span> (<span class="params">classes</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">if</span> (!<span class="keyword">this</span>[i].className.split(<span class="string">' '</span>).includes(classes)) &#123;</span><br><span class="line">        <span class="keyword">this</span>[i].classList.add(classes)</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  nodes.setText = <span class="function"><span class="keyword">function</span> (<span class="params">text</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="keyword">this</span>.length; i++) &#123;</span><br><span class="line">      <span class="keyword">this</span>[i].textContent = text</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> nodes</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>done</strong>.</p>]]></content>
      
      
      
        <tags>
            
            <tag> jQuery </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>函数笔记</title>
      <link href="/2019/03/08/%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/08/%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>函数就是一段可以反复调用的代码块。</li><li>console.log(xxx) 只接受字符串，xxx 不是字符串就调用 toString()。</li><li>函数默认 return undefined。声明变量时也是如此。</li><li><p>函数的 name 属性为 关键字后的 标识符，匿名函数为变量名，奇葩：<br><code>fn = new Funcition(...)</code>，fn.name === “anonymous”</p><a id="more"></a></li></ul><h2 id="函数的-5-种声明"><a href="#函数的-5-种声明" class="headerlink" title="函数的 5 种声明"></a>函数的 5 种声明</h2><ul><li>具名函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name <span class="comment">// 'f'</span></span><br></pre></td></tr></table></figure><ul><li>匿名函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line">f = <span class="function"><span class="keyword">function</span>(<span class="params">x,y</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line">f.name <span class="comment">// 'f'</span></span><br></pre></td></tr></table></figure><ul><li>具名函数赋值</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f</span><br><span class="line">f = <span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params">x,y</span>)</span>&#123; <span class="keyword">return</span> x+y &#125;</span><br><span class="line">f.name <span class="comment">// 'f2'</span></span><br><span class="line"><span class="built_in">console</span>.log(f2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure><ul><li>window.Function</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="keyword">new</span> <span class="built_in">Function</span>(<span class="string">'x'</span>,<span class="string">'y'</span>,<span class="string">'return x+y'</span>)</span><br><span class="line">f.name <span class="comment">// "anonymous"</span></span><br></pre></td></tr></table></figure><p><img src="http://pntmc1hcw.bkt.clouddn.com/fn-2.png" alt="fn-2.png"></p><ul><li>箭头函数</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function">(<span class="params">x,y</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x+y</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">x,y</span>) =&gt;</span> x+y</span><br><span class="line"><span class="keyword">var</span> n2 = <span class="function"><span class="params">n</span> =&gt;</span> n*n</span><br></pre></td></tr></table></figure><p>花括号和 return 可以一起去掉，不能只省略一个；<br>箭头函数没有 <code>arguments</code>。</p><h2 id="如何调用函数"><a href="#如何调用函数" class="headerlink" title="如何调用函数"></a>如何调用函数</h2><p>f.call(asThis, input1,input2)<br>其中 asThis 会被当做 this，[input1,input2] 会被当做 arguments<br>禁止使用 f(input1, input2)，因为学会 .call 才能理解 this</p><h2 id="this-和-arguments"><a href="#this-和-arguments" class="headerlink" title="this 和 arguments"></a>this 和 arguments</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">    'use strict'</span></span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">arguments</span>)</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">undefined</span></span><br><span class="line">&#125;</span><br><span class="line">f.call(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>) <span class="comment">// this 为 1，arguments 为 [2,3]</span></span><br></pre></td></tr></table></figure><h2 id="什么是-call-stack"><a href="#什么是-call-stack" class="headerlink" title="什么是 call stack"></a>什么是 call stack</h2><h2 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h2><ul><li>按照语法树，就近原则</li><li>我们只能确定变量是哪个变量，但是不能确定变量的值</li><li>e.g., 在函数内写 <code>a = 1</code>， 并不是在声明全局变量，只是（1）赋值，（2）按照语法树查找不到声明，才会声明并赋值。</li></ul><p>面试题1</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(a) <span class="comment">// 是多少</span></span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line">f1.call()</span><br></pre></td></tr></table></figure><p>拿到代码直接做——必然会错。请先提升声明</p><p>面试题2</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> a = <span class="number">2</span></span><br><span class="line">    f2.call()</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f2</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(a) <span class="comment">// 是多少</span></span><br><span class="line">&#125;</span><br><span class="line">f1.call()</span><br></pre></td></tr></table></figure><p>拿到代码直接做——必然会错。请先提升声明</p><p>面试题3</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> liTags = <span class="built_in">document</span>.querySelectorAll(<span class="string">'li'</span>)</span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt;liTags.length; i++)&#123;</span><br><span class="line">    liTags[i].onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">        <span class="built_in">console</span>.log(i) <span class="comment">// 点击第3个 li 时，打印 2 还是打印 6？</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>拿到代码直接做——必然会错。请先提升声明</p><h2 id="闭包"><a href="#闭包" class="headerlink" title="闭包"></a>闭包</h2><ul><li>如果一个函数，使用了它范围外的变量，那么（这个函数 + 这个变量）就叫做闭包</li></ul><h2 id="函数的本质"><a href="#函数的本质" class="headerlink" title="函数的本质"></a>函数的本质</h2><p><img src="http://pntmc1hcw.bkt.clouddn.com/fn-3.png" alt="fn-3.png"></p><p>Function对象覆盖了从Object继承来的 <code>toString</code> 方法。对于用户定义的 Function 对象，toString方法返回一个字符串，其中包含用于定义函数的源文本段。</p><p><img src="http://pntmc1hcw.bkt.clouddn.com/fn-4.png" alt="fn-4.png"></p><p><img src="http://pntmc1hcw.bkt.clouddn.com/fn-5.png" alt="fn-5.png"></p><h2 id="其他"><a href="#其他" class="headerlink" title="其他"></a>其他</h2><p>立即执行，不声明全局变量</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="built_in">document</span>.body</span><br><span class="line">    <span class="built_in">console</span>.log(parent)</span><br><span class="line">&#125;).call()</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="built_in">document</span>.body</span><br><span class="line">    <span class="built_in">console</span>.log(parent)</span><br><span class="line">&#125;.call())</span><br><span class="line"></span><br><span class="line"><span class="comment">// + - ! ~ 让浏览器知道后面不是声明</span></span><br><span class="line">-<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> parent = <span class="built_in">document</span>.body</span><br><span class="line">    <span class="built_in">console</span>.log(parent)</span><br><span class="line">&#125;.call()</span><br></pre></td></tr></table></figure><p>代码块：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">    <span class="keyword">let</span> parent = <span class="built_in">document</span>.body <span class="comment">// let 的作用域逃不出花括号</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(parent) <span class="comment">// window</span></span><br></pre></td></tr></table></figure></p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123; <span class="keyword">var</span> parent = <span class="built_in">document</span>.body &#125;</span><br><span class="line"><span class="built_in">console</span>.log(parent) <span class="comment">// window</span></span><br></pre></td></tr></table></figure><p>上述代码相当于<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> parent <span class="comment">// 变量提升</span></span><br><span class="line">&#123; parent = <span class="built_in">document</span>.body &#125;</span><br></pre></td></tr></table></figure></p>]]></content>
      
      
      
        <tags>
            
            <tag> 函数 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Array笔记</title>
      <link href="/2019/03/07/Array%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/07/Array%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ul><li>基本类型构造函数加 new ，才是对象</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number() // 基本类型</span><br><span class="line">new Number() // 对象</span><br></pre></td></tr></table></figure><a id="more"></a><ul><li>创建函数</li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var f = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a+b&apos;)</span><br></pre></td></tr></table></figure><p>数组也可像对象一样赋值（数组是你觉得它是数组）<br><img src="http://pntmc1hcw.bkt.clouddn.com/array-1.png" alt="array-1.png"><br>但是 length 依旧为3<br><img src="http://pntmc1hcw.bkt.clouddn.com/array-2.png" alt="array-2.png"><br>不同遍历方法<br><img src="http://pntmc1hcw.bkt.clouddn.com/array-2-2.png" alt="array-2-2.png"></p><ul><li>伪数组：实例的 <code>[[Prototype]]</code> 内置属性（浏览器中表现为 <code>__proto__</code>）中，没有 <code>Array.prototype</code>。<ul><li>e.g, <code>arguments</code>.</li></ul></li></ul><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function xxx() &#123; console.log(&apos;hi&apos;) &#125;</span><br><span class="line"></span><br><span class="line">// 执行</span><br><span class="line">xxx() </span><br><span class="line">xxx.call()</span><br><span class="line"></span><br><span class="line">// 放到内存中，不执行</span><br><span class="line">xxx</span><br></pre></td></tr></table></figure><ul><li><p>arr.forEach(function (<code>currentValue</code>, <code>index</code>, <code>array</code>) {}, <code>thisArg</code>);<br>通过 <code>this</code> 获取 array<br><img src="http://pntmc1hcw.bkt.clouddn.com/array-3.png" alt="array-3.png"></p></li><li><p>arr.sort(function (a, b) { return a - b }) </p><ul><li>a - b 从小到大；b - a 从大到小。</li><li>只有 sort 会改变原值</li></ul></li><li><p>arr + ‘’ === arr.join() // 实际上调用了 toString() 方法</p></li><li><p>arr.map() 有返回值，map: 映射。</p></li><li><p>arr.filter() 返回布尔值，只留下符合条件的</p><ul><li>filter 和 map 一起用，对过滤的值操作。<code>arr.filter((item, index) =&gt; item === index).map(t =&gt; t + 1)</code></li></ul><p><img src="http://pntmc1hcw.bkt.clouddn.com/array-4.png" alt="array-4.png"><br><img src="http://pntmc1hcw.bkt.clouddn.com/array-6.png" alt="array-6.png"></p></li><li><p>arr.reduce()，reduce(减少，归纳为 =&gt; 求和)<br><code>a.reduce((prevSum, n) =&gt; prevSum + n, 0)</code> prevSum 上一次运算的结果，n 当前值</p><p>范围打劫<br><img src="http://pntmc1hcw.bkt.clouddn.com/array-5-2.png" alt="array-5-2.png"><br><img src="http://pntmc1hcw.bkt.clouddn.com/array-5.png" alt="array-5.png"></p></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> array </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JavaScript 教程 - DOM api 归档</title>
      <link href="/2019/03/06/DOM/"/>
      <url>/2019/03/06/DOM/</url>
      
        <content type="html"><![CDATA[<p>知道有这么个功能就行，详情见 Google or <a href="https://wangdoc.com/javascript/dom/index.html" target="_blank">JavaScript 教程 / DOM</a></p><a id="more"></a><h1 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h1><h2 id="DOM"><a href="#DOM" class="headerlink" title="DOM"></a>DOM</h2><p>DOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。</p><h2 id="节点"><a href="#节点" class="headerlink" title="节点"></a>节点</h2><p>DOM 的最小组成单位叫做节点（node）。</p><p>节点的类型有七种。</p><ul><li>Document：整个文档树的顶层节点</li><li>DocumentType：doctype标签（比如<code>&lt;!DOCTYPE html&gt;</code>）</li><li>Element：网页的各种HTML标签（比如<code>&lt;body&gt;</code>、<code>&lt;a&gt;</code>等）</li><li>Attribute：网页元素的属性（比如class=”right”）</li><li>Text：标签之间或标签包含的文本</li><li>Comment：注释</li><li>DocumentFragment：文档的片段</li></ul><p>浏览器提供一个原生的节点对象Node，七种节点都继承了Node，因此具有一些共同的属性和方法。</p><h2 id="节点树"><a href="#节点树" class="headerlink" title="节点树"></a>节点树</h2><p>DOM 树：节点按所在层级，抽象成树状结构。<br>根节点：<code>&lt;html&gt;</code>。<br>除根节点，其他节点有三种层关系。</p><ul><li>父节点关系（parentNode）：直接的那个上级节点</li><li>子节点关系（childNodes）：直接的下级节点</li><li>同级节点关系（sibling）：拥有同一个父节点的节点</li></ul><h1 id="Node-接口"><a href="#Node-接口" class="headerlink" title="Node 接口"></a>Node 接口</h1><p>  均为 Node.prototype.xxx，不重复写了。</p><ul><li>属性<ul><li><strong>nodeType</strong>：整数，节点类型。(文档-9，元素-1，属性-2，文本-3，文档片断-11，文档类型-10，注释-8），有对应常量(e.g.,Node.DOCUMENT_NODE)。</li><li><strong>nodeName</strong>：节点名，元素大写（e.g.,DIV），#xxx 等。</li><li><strong>nodeValue</strong>：返回字符串，节点文本值，可读写，text、comment、attr 有值，别的 null。div要读儿子的文本。</li><li><strong>textContent</strong>：返回自己和子孙的文本，忽略 HTML 标签。写入时对 HTML 标签转义。有节点该属性为 null。和<code>innerText</code>（IE）有差异，innerText 不包括 style 标签、script 标签，不展示隐藏文本。</li><li><strong>baseURI</strong>：字符串，网页绝对路径。只读。<code>&lt;base&gt;</code> &gt; <code>window.location</code>。</li><li><strong>ownerDocument</strong>：找出我的祖宗。顶层文档对象，即document对象。<code>document.ownerDocument === null</code>。</li><li><strong>nextSibling</strong>：我后面的兄弟。包括文本节点和注释节点。空格也是兄弟。可用来遍历。</li><li><strong>previousSibling</strong>：我前面的兄弟。之后同上。</li><li><strong>parentNode</strong>：找爸爸。有人没爸爸 null。生出来没上户口的 null。<code>node.parentNode.removeChild(node);</code>自己不想活了。</li><li><strong>parentElement</strong>：只要是 element 的爸爸，document 和 documentfragment 滚蛋。</li><li><strong>firstChild</strong>，<strong>lastChild</strong>：第一个儿子（element or text or comment），没有就 null。</li><li><strong>childNodes</strong>：类数组对象，把我的儿子们（text 和 comment 弱鸡也是我的儿子）打包。没儿子给个空包。动态集合。</li><li><strong>isConnected</strong>：布尔值，看看我上户口了没。</li></ul></li><li>方法<ul><li><strong>appendChild</strong>()：喜当爹，送你个娃。返回值是这个娃。例外：娃 是 DocumentFragment 时，自己查。</li><li><strong>hasChildNodes</strong>()：布尔值，我有没有娃（还有2种方法）。</li><li><strong>cloneNode</strong>(deep)：造一个同卵双胞胎。有唯一属性要改、监听\事件\回调 不能克隆。cloneNode(true) 深拷贝</li><li><strong>insertBefore</strong>()：插入父节点内指定元素前。</li><li><strong>removeChild</strong>()：把这个儿子赶出家门。(把不是儿子的人赶出家门会报错)。只是从页面上消失，还是存在于内存中的。</li><li><strong>replaceChild</strong>()：辣鸡，我要换个人做儿子。</li><li><strong>contains</strong>()：布尔值，看看我和子孙们上族谱了没。</li><li><strong>compareDocumentPosition</strong>()：返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。两人可能关系复杂，返回数值为总和，需与掩码 与运算，具体判断。</li><li><strong>isEqualNode</strong>()，<strong>isSameNode</strong>()：布尔值，是否相等。类型相同、属性相同、子节点相同。equal 看起来相同，same 真的是同一个节点。</li><li><strong>isEqualNode</strong>()，<strong>isSameNode</strong>()：布尔值，是否相等。类型相同、属性相同、子节点相同。equal 看起来相同，same 真的是同一个节点。</li><li><strong>normalize</strong>()：去除空文本节点，毗邻的文本节点合并。Text.splitText的逆方法。</li><li><strong>getRootNode</strong>()：作用等于 ownerDocument，but，<code>document.getRootNode() // document</code>。</li></ul></li></ul><h1 id="NodeList-接口，HTMLCollection-接口"><a href="#NodeList-接口，HTMLCollection-接口" class="headerlink" title="NodeList 接口，HTMLCollection 接口"></a>NodeList 接口，HTMLCollection 接口</h1><p>  节点集合：NodeList(contain the various types node) 和 HTMLCollection（HTML element node only）。</p><ul><li><p>NodeList 接口（NodeList.prototype.xxxxx）</p><ul><li>概述：<ul><li>NodeList实例是类数组对象，成员为节点对象。</li><li>创建NodeList实例：（1）Node.childNodes；（2）document.querySelectorAll()等节点搜索方法。</li><li>转为真正的数组：<code>var nodeArr = Array.prototype.slice.call(document.body.childNodes);</code>。</li><li>Node.childNodes 动态集合，别的为静态集合。</li></ul></li><li>length：返回节点数。</li><li>forEach()：用法同数组 forEach()。</li><li>item()：返回该位置成员。</li><li>keys()，values()，entries()：类似 Object.xxx。</li></ul></li><li><p>HTMLCollection 接口（HTMLCollection.prototype.xxx）</p><ul><li>概述：<ul><li>只有元素节点，类数组对象，只能 for 循环遍历。</li><li>HTMLCollection 实例都为动态集合。</li></ul></li><li>length：成员数量。</li><li>item()：返回该位置成员。</li><li>namedItem()：返回 id 或 name 为指定字符串的元素节点，没有就 null。</li></ul></li></ul><p>mdwoyaokantule</p><h1 id="ParentNode-接口，ChildNode-接口"><a href="#ParentNode-接口，ChildNode-接口" class="headerlink" title="ParentNode 接口，ChildNode 接口"></a>ParentNode 接口，ChildNode 接口</h1><ul><li>ParentNode 接口（ParentNode.xxx）<ul><li>children：all child element nodes.</li><li>firstElementChild： nothing special.</li><li>lastElementChild：nothing special..</li><li>childElementCount：nothing special…</li><li>append()，prepend()：添加 元素 or 文字子节点。往后加 / 往前加。</li></ul></li><li>ChildNode 接口（有爸爸就能用）<ul><li>ChildNode.remove()：让自己从世界消失。</li><li>ChildNode.before()，ChildNode.after()：insert sibling before or after myself.</li><li>ChildNode.replaceWith()：替换节点。</li></ul></li></ul><h1 id="Document-节点"><a href="#Document-节点" class="headerlink" title="Document 节点"></a>Document 节点</h1><ul><li>概述：document 节点 -&gt; 整个文档。document 对象有不同办法获取，详情见Google。</li><li><p>属性（document.xxx）</p><ul><li><p>快捷方式属性：</p><ul><li>defaultView：返回 document 对象所属的 window 对象，无则 null。</li><li>doctype：指向<code>&lt;DOCTYPE&gt;</code>节点。</li><li>documentElement：返回当前文档的 根元素节点，一般为 <code>&lt;html&gt;</code> 节点。</li><li>body，head：指向相应节点，代码里不写，浏览器给你加。可写。</li><li>scrollingElement：当前文档的滚动元素。</li><li>activeElement：获得焦点的 DOM 元素。e.g.,<code>&lt;input&gt;</code>、<code>&lt;textarea&gt;</code>、<code>&lt;select&gt;</code>等表单元素。无返回  <code>&lt;body&gt;</code> 或 <code>null</code>。</li><li>fullscreenElement：全屏展示的 DOM 元素。比如查看 <code>&lt;video&gt;</code> 元素是否为全屏状态。</li></ul></li><li><p>节点集合属性：</p><ul><li>links：所有设定了 href 属性的 <code>&lt;a&gt;</code> 及 <code>&lt;area&gt;</code> 节点。</li><li>forms：所有 <code>&lt;form&gt;</code> 节点。可用 id 和 name 来引用。</li><li>images：所有图片节点。可以用 imgList[i].src === ‘xxx’ 来查找某张图。</li><li>embeds，plugins：所有 <code>&lt;embed&gt;</code> 节点。</li><li>scripts：所有。。。</li><li>styleSheets：文档内嵌或引入的样式表集合。</li><li>小结：除了document.styleSheets，别的都返回 HTMLCollection 实例。</li></ul></li></ul></li></ul><p>我挂了，这篇博客先太监吧，IDE 你要学会自己写代码呀</p><pre><code>- 文档静态信息属性：- 文档状态属性：- cookie：- designMode：- implementation：</code></pre><ul><li>方法（document.xxx）<ul><li>open()，close()：open -&gt; write -&gt; close,异步操作时，使用 document.write 容易把页面冲掉</li><li>write()，writeln()：</li><li>querySelector()，querySelectorAll()：</li><li>getElementsByTagName()：</li><li>getElementsByClassName()：</li><li>getElementsByName()：</li><li>getElementById()：</li><li>elementFromPoint()，elementsFromPoint()：</li><li>caretPositionFromPoint()：</li><li>createElement()：</li><li>createTextNode()：</li><li>createAttribute()：</li><li>createComment()：</li><li>createDocumentFragment()：</li><li>createEvent()：</li><li>addEventListener()，removeEventListener()，dispatchEvent()：</li><li>hasFocus()：</li><li>adoptNode()，importNode()：</li><li>createNodeIterator()：</li><li>createTreeWalker()：</li><li>execCommand()，queryCommandSupported()，queryCommandEnabled()：</li><li>getSelection()：</li></ul></li></ul><h1 id="Element-节点"><a href="#Element-节点" class="headerlink" title="Element 节点"></a>Element 节点</h1><ul><li>实例属性<br>元素特性的相关属性<br>元素状态的相关属性<br>Element.attributes<br>Element.className，Element.classList<br>Element.dataset<br>Element.innerHTML<br>Element.outerHTML<br>Element.clientHeight，Element.clientWidth<br>Element.clientLeft，Element.clientTop<br>Element.scrollHeight，Element.scrollWidth<br>Element.scrollLeft，Element.scrollTop<br>Element.offsetParent<br>Element.offsetHeight，Element.offsetWidth<br>Element.offsetLeft，Element.offsetTop<br>Element.style<br>Element.children，Element.childElementCount<br>Element.firstElementChild，Element.lastElementChild<br>Element.nextElementSibling，Element.previousElementSibling</li><li>实例方法<br>属性相关方法<br>Element.querySelector()<br>Element.querySelectorAll()<br>Element.getElementsByClassName()<br>Element.getElementsByTagName()<br>Element.closest()<br>Element.matches()<br>事件相关方法<br>Element.scrollIntoView()<br>Element.getBoundingClientRect()<br>Element.getClientRects()<br>Element.insertAdjacentElement()<br>Element.insertAdjacentHTML()，Element.insertAdjacentText()<br>Element.remove()<br>Element.focus()，Element.blur()<br>Element.click()</li><li>参考链接</li></ul><h1 id="属性的操作"><a href="#属性的操作" class="headerlink" title="属性的操作"></a>属性的操作</h1><ul><li>Element.attributes 属性</li><li>元素的标准属性</li><li>属性操作的标准方法<br>概述<br>Element.getAttribute()<br>Element.getAttributeNames()<br>Element.setAttribute()<br>Element.hasAttribute()<br>Element.hasAttributes()<br>Element.removeAttribute()</li><li>dataset 属性</li></ul><h1 id="Text-节点和-DocumentFragment-节点"><a href="#Text-节点和-DocumentFragment-节点" class="headerlink" title="Text 节点和 DocumentFragment 节点"></a>Text 节点和 DocumentFragment 节点</h1><ul><li>Text 节点的概念</li><li>Text 节点的属性<ul><li>data</li><li>wholeText</li><li>length</li><li>nextElementSibling，previousElementSibling</li></ul></li><li>Text 节点的方法<ul><li>appendData()，deleteData()，insertData()，replaceData()，subStringData()</li><li>remove()</li><li>splitText()</li></ul></li><li>DocumentFragment 节点</li></ul><h1 id="CSS-操作"><a href="#CSS-操作" class="headerlink" title="CSS 操作"></a>CSS 操作</h1><ul><li>HTML 元素的 style 属性</li><li>CSSStyleDeclaration 接口<ul><li>简介</li><li>CSSStyleDeclaration 实例属性</li><li>CSSStyleDeclaration 实例方法</li></ul></li><li>CSS 模块的侦测</li><li>CSS 对象<ul><li>CSS.escape()</li><li>CSS.supports()</li></ul></li><li>window.getComputedStyle()</li><li>CSS 伪元素</li><li>StyleSheet 接口<ul><li>概述</li><li>实例属性</li><li>实例方法</li></ul></li><li>实例：添加样式表</li><li>CSSRuleList 接口</li><li>CSSRule 接口<ul><li>概述</li><li>CSSRule 实例的属性</li><li>CSSStyleRule 接口</li><li>CSSMediaRule 接口</li></ul></li><li>window.matchMedia()<ul><li>基本用法</li><li>MediaQueryList 接口的实例属性</li><li>MediaQueryList 接口的实例方法</li></ul></li></ul><h1 id="Mutation-Observer-API"><a href="#Mutation-Observer-API" class="headerlink" title="Mutation Observer API"></a>Mutation Observer API</h1><ul><li>概述</li><li>MutationObserver 构造函数</li><li>MutationObserver 的实例方法<ul><li>observe()</li><li>disconnect()，takeRecords（）</li></ul></li><li>MutationRecord 对象</li><li>应用示例<ul><li>子元素的变动</li><li>属性的变动</li><li>取代 DOMContentLoaded 事件</li></ul></li><li>参考链接</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 心痛 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>原型与原型链</title>
      <link href="/2019/03/05/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/"/>
      <url>/2019/03/05/%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="单体内置对象"><a href="#单体内置对象" class="headerlink" title="单体内置对象"></a>单体内置对象</h2><p>ECMA-262 内置对象的定义：”由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就存在了”<br>ECMA-262还定义了2个单体内置对象：<strong>Global</strong> 和 <strong>Math</strong>。</p><h3 id="Global对象"><a href="#Global对象" class="headerlink" title="Global对象"></a>Global对象</h3><p>事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。Global对象还包含其他一些方法。<br><a id="more"></a></p><ol><li><strong>URI编码方法</strong><br>encodeURI() : 将空格替换成 %20<br>encodeURIComponent()：使用对应的编码替换所有非字母数字字符。<br>对整个 URI 使用 encodeURI()，对添加在现有 URI 的字符串使用 encodeURIComponent()。<br>解码<br>decodeURI() 、decodeURIComponent()</li><li><strong>eval()方法</strong><br>只接收一个参数，即要执行的ECMAScript（或JavaScript）字符串。<br><code>eval(“alert(‘hello’)”)</code> 等价于 <code>alert(“hello”)</code><br><strong>严格模式</strong>下，在外部访问不到创建在 eval() 中的任何变量和函数；为eval赋值也会导致错误。</li><li><strong>Global对象的属性</strong><br>特殊值：NaN、Infinity、undefined；<br>构造函数：Object, Array, Function, Boolean, String, Number, Date, RegExp, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError</li><li><strong>window对象</strong><br>ECMAScript没有直接说如何访问Global对象，不过Web浏览器都是将Global对象作为window对象的一部分加以实现的。<br>取得Global对象的另一种方法（在任何执行环境下都可行）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var global = function() &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125; ();</span><br></pre></td></tr></table></figure></li></ol><h3 id="Math对象"><a href="#Math对象" class="headerlink" title="Math对象"></a>Math对象</h3><p>Math对象：ECMAScript为保存数学公式和信息提供的公共位置。<br>Math对象提供的计算功能，比我们用JS编写的算法执行更快。</p><ol><li><strong>Math对象的属性</strong><br>数学计算中可能用到的特殊值。例：Math.E，即常量e的值。</li><li><strong>min() 和 max()方法</strong><br>（1）可接受任意多个参数值，返回最大、最小值。<br>var max = Math.max(3, 45, 34, 32);<br>alert(max); // 45<br>（2）用来查询数组对象中的最大、最小值（结合apply()方法）<br>var values = [1, 3, 4, 5, 6];<br>var max = Math.max.apply(Math, values); // 关键是把 Math 对象作为 apply()的第一个参数，从而正确地设置 this 值 </li><li><strong>舍入方法</strong><br>小数舍入为整数<br>Math.ceil(23.7)：向上 // 24<br>Math.floor(23.4)：向下 // 23<br>Math.round(78.5454)：四舍五入 // 79</li><li><strong>random()方法</strong><br>Math.random() 返回一个 大于等于0 小于1的随机数<br>值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值)</li><li><strong>其他方法</strong><br>弦切角，绝对值，自然对数，平方根，幂等。</li></ol><h2 id="创建对象"><a href="#创建对象" class="headerlink" title="创建对象"></a>创建对象</h2><p><a href="https://celesteweng.com/2019/01/24/%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/" target="_blank">对创建对象方法的理解&gt;&gt;</a></p><h2 id="对原型的理解"><a href="#对原型的理解" class="headerlink" title="对原型的理解"></a>对原型的理解</h2><ol><li><strong>函数</strong>有 <strong>prototype</strong> 属性，prototype 属性为一个指针，指向<strong>原型对象</strong>。</li><li><strong>原型对象</strong>默认有 <strong>constructor</strong> 属性，指向 prototype 属性所在的<strong>函数</strong>。</li><li>自定义的构造函数，其原型对象默认只取得 constructor 属性，别的从 Object 继承。</li><li>构造函数创建实例后，<strong>实例</strong>有内部属性 <strong>[[Prototype]]</strong>，指向构造函数的<strong>原型对象</strong>，脚本中没有标准的方式访问。但在 Firefox、Safari 和 Chrome 中，每个对象有属性 <strong><strong>proto</strong></strong>；其他实现中，该属性对脚本不可见。</li><li>判断实例的 [[Prototype]] 属性是否指向某个原型对象（即 实例person1 是否为 构造函数Person 的实例）：<br><code>alert(Person.prototype.isPrototypeOf(person1));  //true</code></li><li>获取实例的 [[Prototype]] 属性的指向 Object.getPrototypeOf(实例)<br><code>alert(Object.getPrototypeOf(person1) == Person.prototype); //true</code><br><code>alert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot;</code></li><li>读取实例的属性时，可以获取原型对象的同名属性的值的原因：和读取对象的属性值得过程有关。</li><li><strong>读取</strong>某个对象某个属性的<strong>过程</strong>：<br>从对象实例开始查找，如果有该名字的属性，返回该属性的值；<br>若没有找到，则继续搜索指向的原型对象，如果有该名字的属性，则返回原型对象中同名属性的值。</li><li>原型对象中的属性不能通过实例修改，但是可以给实例定义同名属性来<strong>覆盖</strong>原型对象中属性的值。</li><li><strong>hasOwnProperty</strong>() 方法：判断<strong>实例</strong>是否有给定名字的<strong>属性</strong>，返回布尔值。<br>可以用来判断访问的是实例属性还是原型对象属性。<br>alert(person1.hasOwnProperty(“name”));  //false</li><li>Object.<strong>getOwnPropertyDescriptors</strong>() 方法：获取<strong>实例属性</strong>的<strong>描述符</strong>，若要获取原型属性的描述符则需要对原型对象使用该方法。 // 此处发现一个bug hhhh，书中（红宝书）方法错了，结尾少了字母 ‘s’。</li></ol><p><img src="http://pntmc1hcw.bkt.clouddn.com/prototypeChat.jpeg" alt="prototype.jpeg"></p><h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><p>许多OO语言都支持两种继承方式：接口继承和实现继承。</p><ul><li>接口继承只继承方法签名，实现继承则继承实际的方法。</li><li>由于函数没有签名，ECMAScript中不能实现接口继承，ECMAScript 只支持实现继承，其实现继承的实现主要依靠原型链。</li></ul><h3 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h3><ul><li>原型链的基本思想：利用原型让一个引用对象继承另一个引用对象的方法和属性。</li><li>实现原型链有一种基本模式，其代码大致如下。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.property = <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.getSuperValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.property;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">this</span>.subproperty = <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 继承了 SuperType</span></span><br><span class="line">SubType.prototype = <span class="keyword">new</span> SuperType();</span><br><span class="line"></span><br><span class="line">SubType.prototype.getSubValue = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="keyword">return</span> <span class="keyword">this</span>.subproperty;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.getSuperType());    <span class="comment">// true</span></span><br></pre></td></tr></table></figure><p> SubType 继承了 SuperType，继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。</p><p> 实现的本质是重写原型对象，代之以一个新类型的实例。（原来存在于 SuperType 实例中的所有方法和属性，现在也存在于 SubType.prototype 中了）</p><p> 需要注意的是，现在 instance.constructor 指向的是 SuperType，因为 SubType.prototype 被重写为 SuperType 的实例。</p><ol><li>别忘记默认的原型<br>所有引用类型默认都继承了 Object，所有函数的默认原型都是 Object 的实例。因此默认原型都是包含一个内部指针，指向 Object.prototype，这也正是所有自定义类型都会继承一些默认方法的根本原因。</li><li>确定原型和实例的关系<br>[1] instanceof 操作符：测试实例和原型链中出现过的构造函数，都会返回 true。<br><code>由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型 的实例。</code><br>[2] isPrototypeOf() 方法：只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此都会返回 true。<br> <code>alert(Object.prototype.isPrototypeOf(instance));    // true</code><br> <code>alert(SuperType.prototype.isPrototypeOf(instance));    // true</code><br> <code>alert(SubType.prototype.isPrototypeOf(instance));    // true</code></li><li>谨慎地定义方法<br>给原型添加方法的代码一定要放在替换原型的语句之后。<br>在通过原型链继承时，不可以用对象字面量创建原型方法，这样会重写原型链。</li><li>原型链的问题<br>没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。</li></ol><h3 id="借用构造函数（伪造对象或经典继承）"><a href="#借用构造函数（伪造对象或经典继承）" class="headerlink" title="借用构造函数（伪造对象或经典继承）"></a>借用构造函数（伪造对象或经典继承）</h3><p>通过使用apply()和call()方法，在新创建的对象上执行构造函数，由此来解决原型中包含引用类型的问题。</p><p>(1) 传递参数<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="comment">//继承了 SuperType，同时还传递了参数 </span></span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, <span class="string">"Nicholas"</span>);+</span><br><span class="line">  <span class="comment">//实例属性</span></span><br><span class="line">    <span class="keyword">this</span>.age = <span class="number">29</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> instance = <span class="keyword">new</span> SubType();</span><br><span class="line">alert(instance.name);    <span class="comment">//"Nicholas";</span></span><br><span class="line">alert(instance.age);     <span class="comment">//29</span></span><br></pre></td></tr></table></figure></p><p>(2) 借用构造函数的问题<br>   方法都在构造函数中定义，无法实现函数复用。</p><h2 id="组合继承（伪经典继承）"><a href="#组合继承（伪经典继承）" class="headerlink" title="组合继承（伪经典继承）"></a>组合继承（伪经典继承）</h2><ul><li>将原型链和借用构造函数的技术结合。思路：使用原型链实现对原型方法和属性的继承，而通过对构造函数实现对实例属性的继承。</li><li>intanceof 和 isPrototypeOf() 能够识别基于组合继承创建的对象。</li></ul><h2 id="原型式继承"><a href="#原型式继承" class="headerlink" title="原型式继承"></a>原型式继承</h2><p>借助原型可以已有的对象创建新对象，同时还不必因此创建自定义类型。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">object</span>(<span class="params">o</span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">F</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">  F.prototype = o;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> F();</span><br><span class="line">&#125;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"Nicholas"</span>,</span><br><span class="line">  friends: [<span class="string">"Shelby"</span>, <span class="string">"Court"</span>, <span class="string">"Van"</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> anotherPerson = object(person);</span><br><span class="line">anotherPerson.name = <span class="string">"Greg"</span>;</span><br><span class="line">anotherPerson.friends.push(<span class="string">"Rob"</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> yetAnotherPerson = object(person);</span><br><span class="line">yetAnotherPerson.name = <span class="string">"Linda"</span>;</span><br><span class="line">yetAnotherPerson.friends.push(<span class="string">"Barbie"</span>);</span><br><span class="line"></span><br><span class="line">alert(person.friends);   <span class="comment">//"Shelby,Court,Van,Rob,Barbie"</span></span><br></pre></td></tr></table></figure><p>ECMAScript5新增的Object.create()，接收2个参数：要继承的对象和（可选）为对象添加额外属性的对象。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person = &#123;</span><br><span class="line">  name: <span class="string">"peanut"</span>,</span><br><span class="line">  friends: [<span class="string">"aaa"</span>, <span class="string">"bbb"</span>]</span><br><span class="line">&#125;;</span><br><span class="line">  </span><br><span class="line"><span class="keyword">var</span> anotherPerson = <span class="built_in">Object</span>.create(person, &#123;</span><br><span class="line">  name: &#123;</span><br><span class="line">  value: <span class="string">"Greg"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">alert(anotherPerson.name); <span class="comment">//"Greg"</span></span><br></pre></td></tr></table></figure><h3 id="寄生式继承"><a href="#寄生式继承" class="headerlink" title="寄生式继承"></a>寄生式继承</h3><ul><li>即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。</li><li>无法函数复用。</li></ul><h3 id="寄生组合式继承"><a href="#寄生组合式继承" class="headerlink" title="寄生组合式继承"></a>寄生组合式继承</h3><ul><li>组合继承中会执行两次超类型的构造函数，导致子类型实例和子类型原型中存在相同的重复属性。</li></ul><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">inheritPrototype</span>(<span class="params">subType, superType</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> prototype = object(superType.prototype); <span class="comment">//创建对象</span></span><br><span class="line">  prototype.constructor = subType; <span class="comment">//增强对象</span></span><br><span class="line">  subType.prototype = prototype; <span class="comment">//指定对象</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SuperType</span>(<span class="params">name</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.colors = [<span class="string">"red"</span>, <span class="string">"blue"</span>, <span class="string">"green"</span>];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">SuperType.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SubType</span>(<span class="params">name, age</span>)</span>&#123;</span><br><span class="line">  SuperType.call(<span class="keyword">this</span>, name);</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inheritPrototype(SubType, SuperType);</span><br><span class="line"></span><br><span class="line">SubType.prototype.sayAge = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  alert(<span class="keyword">this</span>.age);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><blockquote><p>使用寄生组合继承子类型将通过原型链继承超类型的属性和方法，而在子类型实例中将不再有重复的属性。</p></blockquote><h3 id="小结"><a href="#小结" class="headerlink" title="小结"></a>小结</h3><ul><li>继承：将超类型的实例赋值给子类型的 prototype 属性（此时子类型原型对象的 constructor 属性会指向超类型的构造函数），从而继承超类型的所有属性和方法。</li><li>实现继承的方法：<ol><li>原型链</li><li>借用构造函数</li><li>组合继承</li><li>原型式继承</li><li>寄生式继承</li><li>寄生组合式继承</li></ol></li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 原型链 </tag>
            
            <tag> 单体内置对象 </tag>
            
            <tag> Global对象 </tag>
            
            <tag> Math对象 </tag>
            
            <tag> 原型 </tag>
            
            <tag> 继承 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>普通类型和对象的区别</title>
      <link href="/2019/03/04/%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/2019/03/04/%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h2 id="动态类型"><a href="#动态类型" class="headerlink" title="动态类型"></a>动态类型</h2><p>JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：<br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = <span class="number">42</span>;    <span class="comment">// foo is a Number now</span></span><br><span class="line">foo = <span class="string">"bar"</span>; <span class="comment">// foo is a String now</span></span><br><span class="line">foo = <span class="literal">true</span>;  <span class="comment">// foo is a Boolean now</span></span><br></pre></td></tr></table></figure></p><a id="more"></a><h2 id="类型转换"><a href="#类型转换" class="headerlink" title="类型转换"></a>类型转换</h2><h3 id="变-String"><a href="#变-String" class="headerlink" title="变 String"></a>变 String</h3><ol><li>xxx.toString()<br><img src="http://pntmc1hcw.bkt.clouddn.com/tostring.png" alt="tostring.png"><br><code>1.toString</code> 报错；<br><code>1..toString</code> -&gt; <code>&quot;1&quot;</code> 第一个点被当成小数点，第二点用来接 api</li><li>String(xxx)<br><img src="http://pntmc1hcw.bkt.clouddn.com/string.png" alt="string.png"></li><li>‘’ + xxx （推荐）<br><img src="http://pntmc1hcw.bkt.clouddn.com/x+&#39;&#39;.png" alt="x+&#39;&#39;.png"></li></ol><h3 id="变-Boolean"><a href="#变-Boolean" class="headerlink" title="变 Boolean"></a>变 Boolean</h3><ol><li>!!xxx （推荐）</li><li>Boolean(xxx)</li></ol><table><thead><tr><th>类型</th><th>值</th><th>布尔值</th><th>备注</th></tr></thead><tbody><tr><td>number</td><td>0 / NaN</td><td>false</td><td>其余为 true</td></tr><tr><td>string</td><td>“”</td><td>false</td><td>其余为 true</td></tr><tr><td>null</td><td>null</td><td>false</td><td>-</td></tr><tr><td>undefined</td><td>undefined</td><td>false</td><td>-</td></tr><tr><td>object</td><td>{}，包括 Array、Function</td><td>true</td><td>全部为 true</td></tr></tbody></table><blockquote><p>falay 值：0、NaN、null、undefined、空字符串（’’ or “”）、false</p></blockquote><h3 id="变-Number"><a href="#变-Number" class="headerlink" title="变 Number"></a>变 Number</h3><ol><li>‘1’ -&gt; 1<ul><li><code>Number(&#39;1&#39;)</code> === 1</li><li><code>parseInt(&#39;1&#39;, 10)</code> === 1</li><li><code>parseFloat(&#39;1.23&#39;)</code> === 1.23</li><li><code>&#39;1&#39; - 0</code> -&gt; 1 （推荐）</li><li><code>+ &#39;.0&#39;</code> -&gt; <code>0.1</code>; <code>+ &#39;-1&#39;</code> -&gt; <code>-1</code> (并非取绝对值)</li></ul></li></ol><h2 id="Object-、内存"><a href="#Object-、内存" class="headerlink" title="Object 、内存"></a>Object 、内存</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// wrong</span></span><br><span class="line"><span class="keyword">var</span> a = &#123; <span class="attr">self</span>: a &#125;</span><br><span class="line"><span class="comment">// a.self 为 undefined</span></span><br></pre></td></tr></table></figure><p>等价于</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a <span class="comment">// 变量提升</span></span><br><span class="line">a = &#123; <span class="attr">self</span>: a &#125;</span><br></pre></td></tr></table></figure><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// correct</span></span><br><span class="line"><span class="keyword">var</span> a = &#123;&#125;</span><br><span class="line">a.self = a</span><br></pre></td></tr></table></figure><hr><p><strong>引用类型的比较是引用的比较</strong><br><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> person1 = &#123; <span class="string">'name'</span>: <span class="string">'pikachu'</span> &#125;</span><br><span class="line"><span class="keyword">var</span> person2 = &#123; <span class="string">'name'</span>: <span class="string">'pikachu'</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(person1 === person2); <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p><p>虽然变量 person1 和变量 person2 都是表示一个内容为 <code>&#39;name&#39;: &#39;pikachu&#39;</code> 的对象，但是其在内存中的位置不一样，也就是说变量 person1 和变量 person2 指向的不是同一个对象，所以它们是不相等的。<br><img src="http://pntmc1hcw.bkt.clouddn.com/compare.jpg" alt="image.png"></p><hr><p>你买一个 8G 的内存条<br>操作系统开机即占用 512MB<br>Chrome 打开即占用 1G 内存<br>Chrome 各每个网页分配一定数量的内存<br>这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎）<br>JS 引擎将内存分为代码区和数据区<br>我们只研究数据区<br>数据区分为 Stack（栈内存） 和 Heap（堆内存）<br>简单类型的数据直接存在 Stack 里<br>复杂类型的数据是把 Heap 地址存在 Stack 里</p><p><img src="http://pntmc1hcw.bkt.clouddn.com/referenceType.png" alt="referenceType.png"></p><h3 id="垃圾回收"><a href="#垃圾回收" class="headerlink" title="垃圾回收"></a>垃圾回收</h3><p>如果一个对象没有被引用，它就是垃圾，将被回收</p><p><img src="http://pntmc1hcw.bkt.clouddn.com/garbage.png" alt="image.png"></p><p>JavaScript 是一门具有<strong>自动垃圾收集</strong>机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。</p><ul><li><strong>离开作用域</strong>的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。</li><li>“<strong>标记清除</strong>“是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。</li><li>另一种垃圾收集算法是”<strong>引用计数</strong>“，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法;但在 IE 中访问非原生 JavaScript 对象(如 DOM 元素)时，这种算法仍然可能会导致问题。</li><li>当代码中存在<strong>循环引用</strong>现象时，”引用计数”算法就会导致问题。</li><li>解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时<strong>解除</strong>不再使用的全局对象、全局对象属性以及循环引用变量的<strong>引用</strong>。</li></ul><!-- ## 浅拷贝 VS 深拷贝<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var a = 1</span><br><span class="line">var b = a</span><br></pre></td></tr></table></figure><p>b 变不影响 a -&gt; 深拷贝</p><p>基本类型（赋值）都是深拷贝</p><p>一般针对 Object 讨论 –&gt;</p>-->]]></content>
      
      
      
        <tags>
            
            <tag> 类型转换 </tag>
            
            <tag> 垃圾回收 </tag>
            
            <tag> 内存图 </tag>
            
            <tag> 浅拷贝/深拷贝 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS_深入浅出_笔记</title>
      <link href="/2019/03/04/CSS-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/03/04/CSS-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<h2 id="1-CSS-学习思路"><a href="#1-CSS-学习思路" class="headerlink" title="1. CSS 学习思路"></a>1. CSS 学习思路</h2><ol><li>监测是否支持 touch 事件：<br>(1)’ontouchstart’ in documentbody<br>(2)document.body.ontouchstart === undefined (不支持。 === null 支持)</li><li>p标签 内，img float，文字则环绕 <a id="more"></a></li><li>github markdown css</li><li>border 和 margin，display: table.flex, 阻断 margin 的合并；overflow: hidden;</li><li>li 小圆点，display: list-item; 的属性，换了 display，就没有小圆点</li><li>内联元素display: inline/inline-block，position: absolute; 后，-&gt; display: block;</li><li>一元素 position: fixed; 在 css 中插入内容，父级使用 transform: scale(); 此时，该元素变成相对于父级定位</li><li><img src="http://pntmc1hcw.bkt.clouddn.com/css-1-1.png" alt="css-1-1.png"> ‘你好’没有在浮动元素下，相当于文字环绕浮动图片</li><li><a href="https://www.google.com/search?q=CSS+3+generator" target="_blank">CSS 3 generator</a></li><li><a href="//cndevdocs.com" target="_blank">cndevdocs.com</a></li></ol><!-- more --><h2 id="2-宽度与高度"><a href="#2-宽度与高度" class="headerlink" title="2. 宽度与高度"></a>2. 宽度与高度</h2><ol><li><p>元素的高度是行高决定的(单行)。</p><p> 默认行高是字体设计师确定的，在字体文件中有。在自定义很小的行高（比如 1px）时有可能会失效。</p></li><li><p><code>&amp;nbsp;</code>：no break space.</p></li><li><p><code>text-align: justify;</code>： 多行文字两边对齐。</p></li><li><p>如何让单行文字两边对齐？</p><p> <img src="http://pntmc1hcw.bkt.clouddn.com/text-align.png" alt="text-align.png"></p></li><li><p>换行：单词加上 <code>-</code> 才会换行。</p></li><li><p>一行文字超出<strong>省略号</strong></p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.inlineText</span> &#123;</span><br><span class="line">    <span class="attribute">white-space</span>: nowrap;</span><br><span class="line">    <span class="attribute">overflow</span>: hidden;</span><br><span class="line">    <span class="attribute">text-overflow</span>: ellipsis;</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure></li><li><p>多行省略号</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">display</span>: -webkit-box;</span><br><span class="line">  <span class="attribute">-webkit-line-clamp</span>: <span class="number">2</span>;</span><br><span class="line">  <span class="attribute">-webkit-box-orient</span>: vertical;</span><br><span class="line">  <span class="attribute">overflow</span>: hidden;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><p>div 的宽度不是文字决定的。</p></li><li>浏览器份额查询关键系：百度统计 浏览器。</li><li><strong>margin 合并</strong>：父级的四周没有东西挡起来（e.g., border/padding/overflow: hidden;/在父级内加文字可以），父级和子级的 margin 会合并。测试时可以给父级加 <code>outline: 1px solid red</code>。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><h4 id="div-的高度是由什么决定的"><a href="#div-的高度是由什么决定的" class="headerlink" title="div 的高度是由什么决定的"></a>div 的高度是由什么决定的</h4><p>div 高度是由它内部文档流中的元素高度总和<strong>决定</strong>的，并不是相等。<br>div 宽度默认自适应。</p><p><strong>正方形</strong>：</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attribute">border</span>: <span class="number">1px</span> solid;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* 100% 表示和宽度一样 */</span></span><br><span class="line">  <span class="attribute">padding-top</span>: <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h4 id="span-的高度、宽度是由什么决定的"><a href="#span-的高度、宽度是由什么决定的" class="headerlink" title="span 的高度、宽度是由什么决定的"></a>span 的高度、宽度是由什么决定的</h4><p>高度：行高决定。<br>宽度：内容 + 左右margin + 左右padding + 左右border宽度</p><h4 id="文档流"><a href="#文档流" class="headerlink" title="文档流"></a>文档流</h4><p>文档流就是内联元素从左到右，块级元素从上到下。</p><h5 id="脱离文档流"><a href="#脱离文档流" class="headerlink" title="脱离文档流"></a>脱离文档流</h5><p>算高度的时候别算上我</p><ul><li>方法<ul><li>float</li><li>position: absolute;</li><li>position: fixed;</li></ul></li></ul><h4 id="绝对居中"><a href="#绝对居中" class="headerlink" title="绝对居中"></a>绝对居中</h4><p>使用场景：例如父级为全屏显示的元素时。</p><h5 id="子元素要定宽定高"><a href="#子元素要定宽定高" class="headerlink" title="子元素要定宽定高"></a>子元素要定宽定高</h5><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.son</span> &#123;</span><br><span class="line">  <span class="attribute">position</span>: absolute;</span><br><span class="line">  <span class="attribute">top</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">right</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">bottom</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">  <span class="attribute">margin</span>: auto;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h5 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h5><p>IE 不兼容</p><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.dad</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">justify-content</span>: center;</span><br><span class="line">  <span class="attribute">align-items</span>: center;</span><br><span class="line">  <span class="comment">/* height: 100vh; */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="3-堆叠上下文"><a href="#3-堆叠上下文" class="headerlink" title="3. 堆叠上下文"></a>3. 堆叠上下文</h2><p>资料：<a href="https://www.zhangxinxu.com/wordpress/2016/01/understand-css-stacking-context-order-z-index/" target="_blank" rel="noopener">深入理解CSS中的层叠上下文和层叠顺序</a></p><h3 id="什么是堆叠顺序-The-stacking-order"><a href="#什么是堆叠顺序-The-stacking-order" class="headerlink" title="什么是堆叠顺序(The stacking order)"></a>什么是堆叠顺序(The stacking order)</h3><ol><li>background</li><li>border</li><li>块级</li><li>浮动</li><li>内联</li><li>z-index: 0</li><li>z-index: +</li></ol><p>如果是兄弟元素重叠，那么后面的盖在前面的身上。</p><p><img src="http://pntmc1hcw.bkt.clouddn.com//blog/img/stacking-order.png" alt="stacking-order.png"></p><h3 id="堆叠上下文-The-stacking-context"><a href="#堆叠上下文-The-stacking-context" class="headerlink" title="堆叠上下文(The stacking context)"></a>堆叠上下文(The stacking context)</h3><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context" target="_blank" rel="noopener">https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context</a></p><p>可以理解为堆叠作用域。跟 BFC 一样，我们只知道一些属性会触发堆叠上下文，但并不知道堆叠上下文是什么。</p><p>1.根元素 (HTML),<br>1.z-index 值不为 “auto”的 绝对/相对定位，<br>1.一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，<br>1.opacity 属性值小于 1 的元素（参考 the specification for opacity），<br>1.transform 属性值不为 “none”的元素，<br>1.mix-blend-mode 属性值不为 “normal”的元素，<br>1.filter值不为“none”的元素，<br>1.perspective值不为“none”的元素，<br>1.isolation 属性被设置为 “isolate”的元素，<br>1.position: fixed<br>1.在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）<br>1.-webkit-overflow-scrolling 属性被设置 “touch”的元素</p>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>JS_数据类型</title>
      <link href="/2019/03/04/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/2019/03/04/JS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、-JS-的历史"><a href="#一、-JS-的历史" class="headerlink" title="一、 JS 的历史"></a>一、 JS 的历史</h2><ul><li>1991年，李爵士 发明了 www 万维网</li><li>1992年，同事发明了  CSS</li><li>1993年，李爵士 创办了 W3C</li><li>1995年，网景 Netscape（公司） -&gt; Navigator（浏览器） 支持脚本，之前只支持 HTML + CSS<a id="more"></a></li><li>JS 之父：Brendan Eich，JS 最初叫 Mocha -&gt; liveScript -&gt; JavaScript，10天完成了设计</li><li>网景和 Sun 公司（发明 java）达成协议，JS 和 Java 一起发布</li><li>此时 JS 还缺少很多模块，编码有问题，Unicode 在之后才发布了 UTF-8</li><li>1996，MS IE -&gt; JScript</li><li>网景 被打败，开源 -&gt; Firefox</li><li>IE 5.5，MS 推出 JS 发请求功能</li><li>2004，Gmail 利用 JS 发请求功能，做了网页上的程序。JS 变成正式的编程语言</li><li>2010左右，中国 前端 Front-end</li><li>网景为了打败 MS，向 ECMA 申报标准 （ECMAScript）</li><li>JS 不行：全局变量（没有模块化）、标准库（内置代码少）</li><li>ECMAScript 4 死了，ECMAScript 5 做了小升级，步子太小</li><li>ES6：Rails 社区 Ruby —— CoffeeScript，JS 改良版。类，箭头函数</li><li>ES5 不兼容 IE7，ES 6 不兼容 IE8</li></ul><h2 id="二、7种数据类型"><a href="#二、7种数据类型" class="headerlink" title="二、7种数据类型"></a>二、7种数据类型</h2><ul><li>ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说， 每个变量仅仅是一个用于保存值的占位符而已。</li><li>Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回”function”，而其他浏览器在这种情况下会返回 “object”。</li></ul><h3 id="1-Number-数字"><a href="#1-Number-数字" class="headerlink" title="1. Number 数字"></a>1. Number 数字</h3><ul><li><code>.1</code> 可表示 0.1；</li><li>0b 二进制，0o / 前导0 八进制，0x 十六进制</li></ul><h4 id="i-浮点数值"><a href="#i-浮点数值" class="headerlink" title="i. 浮点数值"></a>i. 浮点数值</h4><ul><li>带小数点，但实际上为整型的变量会保存为整型。</li><li>ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法 表示的数值(例如，0.0000003 会被转换成 3e-7)。</li><li>浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。</li><li>我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25，或者是 0.15 和 0.15 都不会有问题。而如前所述，如果这两个数是 0.1 和 0.2，那么测试将无法通过。因此，永远不 要测试某个特定的浮点数值。</li><li>关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家;其他使用相同数值格 式的语言也存在这个问题。</li></ul><h4 id="ii-数值范围"><a href="#ii-数值范围" class="headerlink" title="ii. 数值范围"></a>ii. 数值范围</h4><ul><li>ECMAScript 能够表示的最小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324。</li><li>能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。</li><li>要想确定一个数值是不是有穷的(换句话说，是不是位于最 小和最大的数值之间)，可以使用 isFinite()函数。返 回 Boolean 值。</li><li>访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以 得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着-Infinity 和 Infinity。</li></ul><h4 id="iii-NaN"><a href="#iii-NaN" class="headerlink" title="iii. NaN"></a>iii. NaN</h4><p>  在 ECMAScript 中，任何数值除以 0 会返回 NaN<br>  （但实际上只有 0 除以 0 才会返回 NaN，正数除以 0 返回 Infinity，负数除以 0 返回-Infinity。）<br>  NaN，即非数值(Not a Number)是一个特殊的数值<br>  NaN 与任何值都不相等，包括 NaN 本身<br>  isNaN()函数 ：判断是否为 NaN<br>  parseInt() 函数<br>  var num1 = parseInt(“10”, 2);<br>  var num2 = parseInt(“10”, 8);<br>  var num3 = parseInt(“10”, 10);<br>  var num4 = parseInt(“10”, 16);<br>  //2 (按二进制解析) //8 (按八进制解析) //10(按十进制解析) //16(按十六进制解析) </p><h3 id="2-String-字符串"><a href="#2-String-字符串" class="headerlink" title="2. String 字符串"></a>2. String 字符串</h3><ul><li>空字符串 长度为0，空格字符串 长度为1；</li><li>转义：<code>\</code> + <code>xxx</code>，<code>\n</code> 回车，<code>\t</code> Tab 制表符，长度为1</li><li>多行字符串（不是字符串里有回车）：<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 坑</span><br><span class="line">var s = &apos;1234 \</span><br><span class="line">        5678&apos;</span><br><span class="line"></span><br><span class="line">// 推荐</span><br><span class="line">var s2 = &apos;1234&apos; +</span><br><span class="line">        &apos;5678&apos;</span><br><span class="line"></span><br><span class="line">// 很多空格 会报错，因为没有闭合</span><br><span class="line">var s3 = &apos;1234 \______ </span><br><span class="line">          5678&apos;</span><br><span class="line"></span><br><span class="line">// ES6 特性 模板字符串包含回车 length: 9</span><br><span class="line">var s4 = `1234</span><br><span class="line">6789`</span><br></pre></td></tr></table></figure></li></ul><h3 id="3-Boolean-布尔"><a href="#3-Boolean-布尔" class="headerlink" title="3. Boolean 布尔"></a>3. Boolean 布尔</h3><ul><li>Boolean，数学家，下雨去上课没带伞，肺病死了。。。</li><li><code>if (&quot;222&quot;) { console.log(&#39;代码执行到此处&#39;) }</code> 实际上打印的代码不会执行，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Equality_comparisons_and_sameness#Loose_equality_using" target="_blank">MDN 对于宽松相等有表格总结</a>，”222” -&gt; 222，true -&gt; 1，222 != 1；<br>建议：<br>（1）== 两端有 <code>true</code> 和 <code>false</code>，千万不要使用 == <br>（2）== 两端有 <code>[]</code>、<code>&quot;&quot;</code>，或者 <code>0</code>，尽量不要使用 ==</li></ul><h3 id="4-Symbol-符号"><a href="#4-Symbol-符号" class="headerlink" title="4. Symbol(符号)"></a>4. Symbol(符号)</h3><p>  Symbol 生成一个全局唯一的值。Symbol 的值和名字没有关系。<br>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var a1 = Symbol(&apos;a&apos;)</span><br><span class="line">var a2 = Symbol(&apos;a&apos;)</span><br><span class="line">a1 !== a2 // true</span><br></pre></td></tr></table></figure></p><h3 id="5-Null-对象"><a href="#5-Null-对象" class="headerlink" title="5. Null(对象)"></a>5. Null(对象)</h3><ul><li>要保存对象的变量还没真正保存对象，空对象指针</li><li>调用 typeof null 会返回”object”</li></ul><h3 id="6-Undefined-声明变量后没赋值-没有声明该变量"><a href="#6-Undefined-声明变量后没赋值-没有声明该变量" class="headerlink" title="6. Undefined(声明变量后没赋值 / 没有声明该变量)"></a>6. Undefined(声明变量后没赋值 / 没有声明该变量)</h3><ul><li>未初始化的变量会自动被赋予 undefined 值，显式地初始化变化更为明智。如此在 typeof 操作符返回 ‘undefined’ 值时，可知道被检测变量还未被声明。</li></ul><h3 id="7-Object-对象"><a href="#7-Object-对象" class="headerlink" title="7. Object 对象"></a>7. Object 对象</h3><ul><li>key 不加引号，要遵守标识符的规则: <br>（1）不能数字开头；（2）不能有空格；（3）合法字符</li><li>key 符合标识符的情况下可用 <code>obj.key</code>，其余 <code>obj[&#39;key&#39;]</code></li><li><code>delete obj[&#39;key&#39;]</code> 删除 key，<code>obj[&#39;key&#39;] = undefined</code> 只是将值置为 undefined</li></ul><h2 id="typeof-操作符"><a href="#typeof-操作符" class="headerlink" title="typeof 操作符"></a>typeof 操作符</h2><p>“undefined”——如果这个值未定义;<br>“boolean”——如果这个值是布尔值;<br>“number”——如果这个值是数值;<br>“object”——如果这个值是对象或 <code>null</code>;<br>“function”——如果这个值是函数。 // function 不在7种类型中</p><p>调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用。 </p><p>Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回”function”，而其他浏览器在这种情况下会返回 “object”。</p>]]></content>
      
      
      
        <tags>
            
            <tag> JS的历史 </tag>
            
            <tag> JS数据类型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>算法初级 &amp; 数据结构</title>
      <link href="/2019/02/28/%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7/"/>
      <url>/2019/02/28/%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7/</url>
      
        <content type="html"><![CDATA[<p>体育委员两两摸头法（冒泡排序）无序区两两比较，最大的放到有序区前端<br>体育老师一指禅法（选择排序）找出最小的，放到最前<br>起扑克牌法（插入排序）<br>强迫症收扑克牌法（基数排序）<br>快排<br>归并排序<br>堆排序<br>排序可视化：<a href="https://visualgo.net/bn/sorting" target="_blank" rel="noopener">https://visualgo.net/bn/sorting</a><br><a id="more"></a></p><h2 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h2><h3 id="哈希表（Hash-Table）"><a href="#哈希表（Hash-Table）" class="headerlink" title="哈希表（Hash Table）"></a>哈希表（Hash Table）</h3><ul><li><strong>计数排序</strong>中的桶（复杂度 O(n+max)，比快排还快<ol><li>使用场景：如 年龄统计（最大值不能过大）</li><li>优点：速度快</li><li>缺点：（1）需要一个哈希作为计数工具；（2）无法对负数和小数进行排序。</li></ol></li><li><a href="http://bubkoo.com/2014/01/15/sort-algorithm/bucket-sort/" target="_blank"><strong>桶排序</strong></a> 与计数排序的区别: 每个桶内放某个范围内的数字，每个桶内可再排序；比计数排序节省空间，浪费时间。</li><li><a href="http://bubkoo.com/2014/01/15/sort-algorithm/radix-sort/" target="_blank"><strong>基数排序</strong></a> 与计数排序的区别：桶的个数的固定的，先比个位数，再比十位数，以此类推，适合大数字的排序。</li></ul><h3 id="队列（Queue）push-shift"><a href="#队列（Queue）push-shift" class="headerlink" title="队列（Queue）push / shift"></a>队列（Queue）push / shift</h3><ul><li>先进先出</li><li>可以用数组实现</li><li>举例：排队</li></ul><h3 id="栈（Stack）push-pop"><a href="#栈（Stack）push-pop" class="headerlink" title="栈（Stack）push / pop"></a>栈（Stack）push / pop</h3><ul><li>先进后出</li><li>可以用数组实现</li><li>举例：盗梦空间</li></ul><h3 id="链表（Linked-List）"><a href="#链表（Linked-List）" class="headerlink" title="链表（Linked List）"></a>链表（Linked List）</h3><ul><li>数组无法直接删除中间的一项，链表可以，但是要取到第N项则较麻烦</li><li>用哈希（JS里面用对象表示哈希）实现链表</li><li>head、node 概念</li></ul><h3 id="树（tree）"><a href="#树（tree）" class="headerlink" title="树（tree）"></a>树（tree）</h3><ul><li>举例：层级结构、DOM</li><li>概念：层数、深度、节点个数</li><li>二叉树</li><li>满二叉树</li><li>完全二叉树</li><li>完全二叉树和满二叉树可以用数组实现</li><li>其他树可以用哈希（对象）实现</li><li>操作：增删改查</li><li>堆排序用到了 tree</li><li>其他：B树、红黑树、AVL树</li></ul><p><a href="https://www.cs.usfca.edu/~galles/visualization/HeapSort.html" target="_blank">堆排序可视化 &gt;&gt;</a><br><a href="http://bubkoo.com/2014/01/14/sort-algorithm/heap-sort/" target="_blank">堆排序JS代码完整讲解 &gt;&gt;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> 哈希 </tag>
            
            <tag> 队列 </tag>
            
            <tag> 栈 </tag>
            
            <tag> 链表 </tag>
            
            <tag> 树 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS_盒模型</title>
      <link href="/2019/02/28/CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B/"/>
      <url>/2019/02/28/CSS-%E7%9B%92%E6%A8%A1%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念"><a href="#一、基本概念" class="headerlink" title="一、基本概念"></a>一、基本概念</h2><p><strong>IE模型</strong>：width/height 只包含content<br><strong>标准模型</strong>：width/height 包含content + padding + border</p><ul><li>内联样式：<ol><li>行内的</li><li>写在html的style标签内的。</li></ol></li><li>外联样式：link引入的样式表。</li></ul><a id="more"></a><h2 id="二、JS如何设置盒模型对应的宽和高"><a href="#二、JS如何设置盒模型对应的宽和高" class="headerlink" title="二、JS如何设置盒模型对应的宽和高"></a>二、JS如何设置盒模型对应的宽和高</h2><ul><li>dom.style.width/height: 只能获取内联样式，不够准确。</li><li>dom.currentStyle.width/height：浏览器渲染之后的样式，不管之前样式是怎么获取的，比较准确，但只有IE支持。</li><li>window.getComputedStyle(dom).width/height: 和上一个api原理相似，只不过可以兼容FireFox和chome。</li><li><strong>dom.getBoundingClientRect().width/height</strong>: 这个api也可以获取准确的属性值，可以获取相对视窗的绝对位置（左上角），有4个属性：<ol><li>top</li><li>left</li><li>width</li><li>height</li></ol></li></ul><h2 id="三、边距重叠问题"><a href="#三、边距重叠问题" class="headerlink" title="三、边距重叠问题"></a>三、边距重叠问题</h2><ol><li>取较大值</li><li><p>利用如下实例说明</p> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//父级 height:100px; </span><br><span class="line">//子集 height：100px; 有 margin-top:10px;</span><br><span class="line">//且父级的背景色不显示</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"sec"</span>&gt;</span> </span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#sec</span>&#123;</span></span><br><span class="line"><span class="undefined">            background: red;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-top</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure> <figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">//父级高度变为 110px；</span><br><span class="line">// BFC(边距重叠解决方案)</span><br><span class="line"><span class="tag">&lt;<span class="name">section</span> <span class="attr">id</span>=<span class="string">"sec"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">        <span class="selector-id">#sec</span>&#123;</span></span><br><span class="line"><span class="undefined">            background: red;</span></span><br><span class="line"><span class="undefined">            overflow: hidden; //增加该属性</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="css">        <span class="selector-class">.child</span>&#123;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">height</span><span class="selector-pseudo">:100px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">margin-top</span><span class="selector-pseudo">:10px</span>;</span></span><br><span class="line"><span class="css">            <span class="selector-tag">background</span><span class="selector-pseudo">:yellow</span>;</span></span><br><span class="line"><span class="undefined">        &#125;</span></span><br><span class="line"><span class="undefined">    </span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">article</span> <span class="attr">class</span>=<span class="string">"child"</span>&gt;</span><span class="tag">&lt;/<span class="name">article</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">section</span>&gt;</span></span><br></pre></td></tr></table></figure></li></ol><ul><li>BFC的<strong>概念</strong>：块级元素格式化上下文(相应的-IFC-内联元素格式化上下文)</li><li>BFC的<strong>原理</strong>（渲染规则）<ol><li>在BFC这个元素的垂直方向的边距会产生重叠</li><li>BFC的区域不会与浮动元素的box重叠（用来清除浮动）</li><li>BFC在页面上是一个独立的容器，外面的元素不会影响它里面的元素，反之亦然</li><li>计算BFC高度时，浮动元素也会参与计算</li></ol></li><li>如何<strong>创建</strong>BFC<ol><li>float值不为none；</li><li>position的值不是static或relative；</li><li>display值为table、table-cell等和table有关的，block, list-item；</li><li>overflow值不为visible，即hidden、scroll、auto都可，inherit(从父元素继承 overflow属性的值,所以不确定，因为可能继承到visible)</li></ol></li><li>BFC的<strong>使用场景</strong>：<ol><li>边距重叠：给元素添加一个父级，并给父级创建BFC。（测试发现直接对元素创建BFC不管用，还是需要父级）</li><li>浮动元素重叠：2个浮动的元素，高度固定，当其中一块的内容超出，该元素会与另一浮动元素重叠，++对高度超出的元素创建BFC++，可解决该问题</li><li>清除浮动：BFC子元素即使是float，也会参与高度计算。（例子：子元素浮动，高度为100px，在浏览器F12发现父级高度为0，原因是float脱离文档流，没有参与计算，当给父级创建BFC，BFC计算高度时，浮动元素也会参与计算，此时父级高度变为了100px；若子元素为文字，父级有背景色，在清除浮动后，父级的背景色才可见。这就是之前用overflow：hidden；清除浮动的原理）</li></ol></li></ul><hr><h3 id="扩展"><a href="#扩展" class="headerlink" title="扩展"></a>扩展</h3><ul><li>float: left/right/none/inherit</li><li>position:<br>  absolute: 绝对定位, 相对于 static 定位以外的第一个父元素进行定位。<br>  fixed: 绝对定位, 相对于浏览器窗口进行定位。<br>  relative: 相对定位, 相对于其正常位置进行定位。<br>  static: 默认值。没有定位，元素出现在正常的流中。<br>  inherit: 从父元素继承 position 属性的值。</li><li>overflow:<br>  visible: 默认值。内容不会被修剪，会呈现在元素框之外。<br>  hidden: 内容会被修剪，并且其余内容是不可见的。<br>  scroll: 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。<br>  auto: 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。<br>  inherit: 从父元素继承 overflow 属性的值。</li><li>display:</li></ul><table><thead><tr><th>值</th><th>描述</th></tr></thead><tbody><tr><td>none</td><td>此元素不会被显示。</td></tr><tr><td>block</td><td>此元素将显示为块级元素，此元素前后会带有换行符。</td></tr><tr><td>inline</td><td>默认。此元素会被显示为内联元素，元素前后没有换行符。</td></tr><tr><td>inline-block</td><td>行内块元素。（CSS2.1 新增的值）。</td></tr><tr><td>list-item</td><td>此元素会作为列表显示。</td></tr><tr><td>run-in</td><td>此元素会根据上下文作为块级元素或内联元素显示。</td></tr><tr><td>compact</td><td>CSS中有值compact，不过由于缺乏广泛支持，已经从CSS2.1中删除。</td></tr><tr><td>marker</td><td>CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。</td></tr><tr><td>table</td><td>此元素会作为块级表格来显示（类似table），表格前后带有换行符。</td></tr><tr><td>inline-table</td><td>此元素会作为内联表格来显示（类似table），表格前后没有换行符。</td></tr><tr><td>table-row-group</td><td>此元素会作为一个或多个行的分组来显示（类似tbody）。</td></tr><tr><td>table-header-group</td><td>此元素会作为一个或多个行的分组来显示（类似thead）。</td></tr><tr><td>table-footer-group</td><td>此元素会作为一个或多个行的分组来显示（类似tfoot）。</td></tr><tr><td>table-row</td><td>此元素会作为一个表格行显示（类似 tr）。</td></tr><tr><td>table-column-group</td><td>此元素会作为一个或多个列的分组来显示（类似colgroup）。</td></tr><tr><td>table-column</td><td>此元素会作为一个单元格列显示（类似 col）。</td></tr><tr><td>table-cell</td><td>此元素会作为一个表格单元格显示（类似 td 和 th）。</td></tr><tr><td>table-caption</td><td>此元素会作为一个表格标题显示（类似 caption）。</td></tr><tr><td>inherit</td><td>规定应该从父元素继承 display 属性的值。</td></tr></tbody></table>]]></content>
      
      
      
        <tags>
            
            <tag> 清除浮动的原理 </tag>
            
            <tag> BFC </tag>
            
            <tag> JS获取宽高 </tag>
            
            <tag> IE模型 </tag>
            
            <tag> 标准模型 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS_布局&amp;小技巧</title>
      <link href="/2019/02/28/CSS-%E5%B8%83%E5%B1%80-%E5%B0%8F%E6%8A%80%E5%B7%A7/"/>
      <url>/2019/02/28/CSS-%E5%B8%83%E5%B1%80-%E5%B0%8F%E6%8A%80%E5%B7%A7/</url>
      
        <content type="html"><![CDATA[<h2 id="左中右布局"><a href="#左中右布局" class="headerlink" title="左中右布局"></a>左中右布局</h2><p><a href="https://celesteweng.com/CSS_layout/horizontal-layout.html" target="_blank">查看在线 demo （调整浏览器宽度见效果）</a></p><ul><li>5种布局：float、绝对定位、flex、表格、网格</li><li>网格布局兼容性差，测试发现chome、FireFox新版本兼容，360浏览器grid挂了。</li></ul><ol><li>浮动-优点：兼容性高；缺点：浮动要清除，关系要处理好</li><li>绝对定位-优点：快捷；缺点：脱离文档流了，之后的元素也要脱离文档流，可使用性差</li><li>flex-css3出现，移动端，比较完美，不兼容IE8</li><li>表格-优点：兼容性好，缺点：三栏，其中一个单元格高度超出，别的单元格也会调整</li><li>网格-新技术-优点：代码量少，缺点：只兼容ie11+</li></ol><a id="more"></a><h2 id="垂直布局"><a href="#垂直布局" class="headerlink" title="垂直布局"></a>垂直布局</h2><p><a href="https://celesteweng.com/CSS_layout/vertical-layout.html" target="_blank">查看在线 demo （调整浏览器高度见效果）</a></p><ul><li>4种布局：绝对定位、flex、表格、网格</li><li>网格布局兼容性差，测试发现chome、FireFox新版本兼容，360浏览器grid挂了。 垂直方向与水平方向在编写是略有不同，需要设<figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">html, body, ...&#123; //省略号代表包含items的标签</span><br><span class="line">    height:100%;</span><br><span class="line">    width:... //宽度自设</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li></ul><h2 id="左右布局-资料来自博客，抄抄大法好"><a href="#左右布局-资料来自博客，抄抄大法好" class="headerlink" title="左右布局 (资料来自博客，抄抄大法好)"></a>左右布局 (资料来自博客，抄抄大法好)</h2><ul><li>分类：2列定宽（不说了）、1列定宽、2列都自适应</li></ul><h3 id="左列定宽，右列自适应"><a href="#左列定宽，右列自适应" class="headerlink" title="左列定宽，右列自适应"></a>左列定宽，右列自适应</h3><h4 id="margin-float"><a href="#margin-float" class="headerlink" title="margin + float"></a>margin + float</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right-fix"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span><span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span> &#123;</span><br><span class="line">    float: left;     //向左浮动</span><br><span class="line">    width: 100px;    //固定宽度</span><br><span class="line">    <span class="selector-tag">position</span>: <span class="selector-tag">relative</span>;</span><br><span class="line">    //由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right-fix</span> &#123;</span><br><span class="line">    float: right;     //向右浮动</span><br><span class="line">    width: 100%;    //为了自适应设为100%</span><br><span class="line">    <span class="selector-tag">margin-left</span>: <span class="selector-tag">-100px</span>;</span><br><span class="line">    //由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span> &#123;</span><br><span class="line">    <span class="attribute">margin-left</span>: <span class="number">120px</span>;</span><br><span class="line">    //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法其实已经是兼顾到低版本IE的完善版本了，缺点是代码冗长，而且有两个关键知识点比较难理解：</p><ol><li>给.left加上position:relative;怎么就能让.left冒出来而不受.right-fix的遮挡了呢？</li><li>.right-fix设置负的margin-left，怎么就能使.left与.right-fix重合了呢？</li></ol><p>再者，这个方案由于.right-fix的margin-left和.left的width高度耦合，因此无法实现自适应，只能应用在左列（当然右列也成）固定宽度的场景。</p><h4 id="absolute"><a href="#absolute" class="headerlink" title="absolute"></a>absolute</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: relative;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    <span class="attribute">left</span>: <span class="number">0</span>;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">position</span>: absolute;</span><br><span class="line">    left: 120px;    //比.left的left多出20px，相当于间隔</span><br><span class="line">    <span class="selector-tag">right</span>: 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这种方法是通过absolute配合left/right进行布局：</p><ol><li>设置display: absolute后，通过top/right/bottom/left可以实现对元素的位置进行像素级的任意控制。因此，使用left属性即可控制各元素的起始位置，避免重叠。</li><li>自适应的关键在于left和right属性，在对元素同时设置这两个属性后，元素的宽度便会遭到拉伸，实现自适应。</li><li>需要注意的是父级元素需要设置display: relative。</li></ol><p>这种方案很容易理解，但缺点就是不能做到“<strong>不定宽</strong>”，因为.left和.right的left属性的值高度相关。</p><h3 id="左列不定宽，右列自适应"><a href="#左列不定宽，右列自适应" class="headerlink" title="左列不定宽，右列自适应"></a>左列不定宽，右列自适应</h3><h4 id="float-BFC"><a href="#float-BFC" class="headerlink" title="float + BFC"></a>float + BFC</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">float</span>: left;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    margin-right: 20px;    //形成20px的间隔</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    overflow: hidden; //通过设置overflow: hidden来触发BFC特性</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法主要是应用到BFC的一个特性：</p><ol><li>浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。</li><li>若浮动元素的块状兄弟元素为BFC，则不会占满一整行，而是根据浮动元素的宽度，占据该行剩下的宽度，避免与浮动元素重叠。</li><li>浮动元素与其块状BFC兄弟元素之间的margin可以生效，这将继续减少兄弟元素的宽度。</li></ol><p>并不是一定要在.right上用overflow: hidden;，只要能触发BFC就好了，另外在IE6上也可以触发haslayout特性（推荐用*zoom: 1;）。</p><p>由于.right的宽度是自动计算的，不需要设置任何与.left宽度相关的css，因此.left的宽度可以不固定（由内容盒子决定）。</p><h4 id="table布局"><a href="#table布局" class="headerlink" title="table布局"></a>table布局</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table; <span class="attribute">width</span>: <span class="number">100%</span>;</span><br><span class="line">    <span class="attribute">table-layout</span>: fixed;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>,<span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: table-cell;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">width</span>: <span class="number">100px</span>;</span><br><span class="line">    <span class="attribute">padding-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这个方法是表格布局的典型运用。说真的，我也很迷惘要不要使用表格布局，毕竟已经是上个时代的产物了，虽然已经不再用<code>&lt;table&gt;</code>的HTML结构了，但用上相应的CSS其实思路跟以前是变化不大的。</p><p>这个方法主要是利用了表格(table)的宽度必然等于其所有单元格(table-cell)加起来的总宽度，那么只要表格的宽度一定，其中一个（或几个）单元格的宽度也一定，那么另外一个未设置宽度的单元格则会默认占满剩下的宽度，即实现自适应。</p><h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"parent"</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"left"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>left<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">div</span> <span class="attr">class</span>=<span class="string">"right"</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">p</span>&gt;</span>right<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span><br></pre></td></tr></table></figure><figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span>&#123;</span><br><span class="line">    <span class="attribute">display</span>: flex;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span>&#123;</span><br><span class="line">    <span class="attribute">margin-right</span>: <span class="number">20px</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.right</span>&#123;</span><br><span class="line">    <span class="attribute">flex</span>: <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="selector-class">.left</span> <span class="selector-tag">p</span>&#123;<span class="attribute">width</span>: <span class="number">200px</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>flex布局的自适应我就不多说了，本来就是设计来自适应的，只需要用上<code>flex: 1;</code>，就能让.right分到.parent的宽度减去.left的宽度。</p><h4 id="推荐使用"><a href="#推荐使用" class="headerlink" title="推荐使用"></a>推荐使用</h4><p>比较推荐用float + <code>BFC</code>方案，浏览器兼容性很好，代码量也少，另外也很好理解；移动端上也可以考虑用上flex方案，不过还是那一句，注意用旧版的flex，兼容性会好一点。</p><h4 id="BFC-是什么？我失忆了，翻了下笔记"><a href="#BFC-是什么？我失忆了，翻了下笔记" class="headerlink" title="BFC 是什么？我失忆了，翻了下笔记"></a>BFC 是什么？我失忆了，翻了下笔记</h4><p><a href="https://celesteweng.github.io/2019/02/28/CSS-盒模型/" target="_blank">详情见 &gt;&gt; CSS 盒模型</a></p><h2 id="水平居中-垂直居中"><a href="#水平居中-垂直居中" class="headerlink" title="水平居中/垂直居中"></a>水平居中/垂直居中</h2><p><a href="https://css-tricks.com/centering-css-complete-guide/" target="_blank" rel="noopener">https://css-tricks.com/centering-css-complete-guide/</a></p><p>文盲如何看懂英文，chrome 浏览器 翻译</p><hr><h2 id="其他小技巧"><a href="#其他小技巧" class="headerlink" title="其他小技巧"></a>其他小技巧</h2><ol><li>行内元素设置了 position：fixed/absolute 或者 float 属性，即<code>脱离文档流</code>，display 隐性更改为 inline-block</li><li>加了 <code>display:inline-block;</code>，元素底部多出间隙，加 <code>vertical-align:top;</code></li><li>行内元素不能设置宽高，上下边距</li><li>所有的非空标签都有伪类（::before ::after）</li><li>height 和width高度不要定死，容易出bug</li><li>ionic 中用 <code>position：fixed</code> 容易变态</li><li><a href="https://segmentfault.com/a/1190000005863953" target="_blank">【译】22个必备的CSS小技巧</a></li><li>搞来抄一抄 https://codepen.io/pens/</li><li>Google</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>老博客</title>
      <link href="/2019/02/27/%E8%80%81%E5%8D%9A%E5%AE%A2/"/>
      <url>/2019/02/27/%E8%80%81%E5%8D%9A%E5%AE%A2/</url>
      
        <content type="html"><![CDATA[<p>源文件没了，只能痛哭流涕了  <a href="https://celesteweng.com/woshihuasheng.github.io/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/</a><br>DOM事件类 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/10/29/dom/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/10/29/dom/</a><br>CSS盒模型 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/10/29/box/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/10/29/box/</a><br>5种css自适应布局-垂直 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-vertical/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-vertical/</a><br>5种css自适应布局-水平 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-horizontal/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-horizontal/</a><br>js整理4 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/08/20/js整理4/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/08/20/js整理4/</a><br>js整理3 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/08/17/js整理3/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/08/17/js整理3/</a><br>js整理2 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/08/16/js整理2/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/08/16/js整理2/</a><br>js整理 <a href="https://celesteweng.com/woshihuasheng.github.io/2017/08/10/js整理/" target="_blank" rel="noopener">https://celesteweng.com/woshihuasheng.github.io/2017/08/10/js整理/</a></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>CSS笔记</title>
      <link href="/2019/02/27/CSS%E7%AC%94%E8%AE%B0/"/>
      <url>/2019/02/27/CSS%E7%AC%94%E8%AE%B0/</url>
      
        <content type="html"><![CDATA[<ol><li>文档流：文档内元素的流动方向。<ul><li>内联元素：从左往右移动，如果遇到宽度不够，另起一行，继续流动。内联元素如果是个很长的单词，它是不会换行分开的，需设置 <code>word-break: break-all;</code>。<code>break-word</code>：在单词分割处中断。</li><li>块级元素：每一个块都占一行，每一个块从上往下依次流。</li></ul></li><li>块级元素 高度：由其内部文档流元素 的高度 总和决定。</li><li>内联元素 高度：不同字体有不同的建议行高，行高可以改变内联元素高度。span 的 border 并不是内联元素的高度。</li><li>CSS 画三角形，可先把每个方向的 border 设置为不同颜色再慢慢试。</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS学习资源</title>
      <link href="/2019/02/26/CSS%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/"/>
      <url>/2019/02/26/CSS%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90/</url>
      
        <content type="html"><![CDATA[<h2 id="CSS-学习资源"><a href="#CSS-学习资源" class="headerlink" title="CSS 学习资源"></a>CSS 学习资源</h2><ol><li>Google: 关键词 MDN</li><li><a href="https://css-tricks.com/" target="_blank">CSS Tricks</a></li><li><a href="https://www.google.com/search?q=%E9%98%AE%E4%B8%80%E5%B3%B0+css" target="_blank">Google: 阮一峰 css</a></li><li><a href="https://www.zhangxinxu.com/wordpress/category/css/page/25/" target="_blank">张鑫旭的 240 多篇 CSS 博客</a></li><li><a href="https://tympanus.net/codrops/category/playground/" target="_blank">Codrops 炫酷 CSS 效果</a></li><li><a href="http://www.ituring.com.cn/book/1695" target="_blank">CSS揭秘</a></li><li><a href="http://cndevdocs.com/" target="_blank">CSS 2.1 中文 spec</a></li><li><a href="https://adamschwartz.co/magic-of-css/" target="_blank">Magic of CSS 免费在线书</a></li></ol><h2 id="周边工具"><a href="#周边工具" class="headerlink" title="周边工具"></a>周边工具</h2><ol><li>LESS CSS</li><li>一种简化、功能更多的 CSS 语言 中文官网(Google: less css 中文官网) 英文官网(Google: less css)</li><li>SASS</li><li>一种简化、功能更多的 CSS 语言（请自行搜索中英文官网）</li><li>PostCSS</li><li>一种 CSS 处理程序</li></ol><ul><li>各种形状 <a href="https://css-tricks.com/the-shapes-of-css/" target="_blank" rel="noopener">https://css-tricks.com/the-shapes-of-css/</a></li><li>生成渐变色 Google: CSS gradient generator</li><li>生成阴影 Google：CSS shadow generator</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> CSS </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML标签</title>
      <link href="/2019/02/25/HTML%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/02/25/HTML%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="iframe-标签"><a href="#iframe-标签" class="headerlink" title="iframe 标签"></a>iframe 标签</h2><p>嵌套页面</p><p><code>&lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt;</code></p><ol><li><code>name</code> 属性可以和 a 标签配合使用</li><li>使用 <code>frameborder=&quot;0&quot;</code> 去掉元素边框</li><li>相当新开一个窗口，用起来卡</li><li><code>src</code> 可以写相对路径</li></ol><a id="more"></a><h2 id="a-标签"><a href="#a-标签" class="headerlink" title="a 标签"></a>a 标签</h2><p>跳转页面（HTTP GET 请求）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/a" target="_blank">a 的更多属性见 &gt;&gt; MDN</a></p><ol><li><p>target 属性（结合 iframe 理解）</p><ul><li><code>_self</code>：在当前页面打开（默认）</li><li><code>_blank</code>：在空页面打开</li><li><code>_partent</code>：父框架集或父窗口打开</li><li><code>_top</code>：祖宗窗口中打开</li><li>framename：在指定的 <code>iframe</code> 标签中打开</li></ul></li><li><p>href 可以输入的内容</p><ul><li>使用 http 协议或 https 协议：<code>http://qq.com</code>  <code>https://qq.com</code></li><li>使用和当前页面相同的协议，无协议绝对地址: <code>//qq.com</code> (直接预览为 file 协议，使用 http-server: <code>npm i -g http-server</code>, <code>http-server</code> or <code>hs</code> 可直接执行，<code>http-server -c-1</code> 不要缓存)</li><li>相对路径 (跳转到 /xxx.html)：<code>xxx.html</code></li><li>锚点（不会发送请求，页面内跳转，别的都要发起请求）：<code>#xxx</code></li><li>查询参数：<code>?name=qqqq</code></li><li>伪协议：<code>javascript:alert(1);</code> （执行 js 代码）；<code>javascript:;</code>(需要写a标签，但是点击之后不需要跳转。直接写 <code>href=&quot;#&quot;</code> 会跳到页面顶部，<code>href=&quot;&quot;</code> 回刷新当前页，不写 href，a 标签变 span)</li></ul><p>错误的：</p><ul><li><code>qq.com</code>：为相对位置，当文件打开</li></ul></li><li><p>download 属性：将链接变成可下载的。</p><blockquote><p>另一方法：HTTP 响应头中设置 <code>Content-Type: application/octet-stream</code>，浏览器默认处理字节流的方式是下载</p></blockquote></li><li><p>title 属性：规定额外信息，通常鼠标移到元素上显示这些信息。</p></li></ol><h2 id="form-标签"><a href="#form-标签" class="headerlink" title="form 标签"></a>form 标签</h2><p>跳转页面（HTTP POST 请求）</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/form" target="_blank">form 的更多属性见 &gt;&gt; MDN</a></p><ol><li>和 a 标签的区别是发起请求的类型不同。action 类似于 href，target 和 a标签的一样</li><li>GET 请求：表单信息变成查询参数，会出现在 url 里，请求头中无法有第四部分（Form Data）；<br>POST 请求：表单信息作为 HTTP 请求的第四部分提交到服务器，如果要写查询参数，可直接写在 action 属性中， <code>action=&quot;users?age=33&quot;</code></li><li>method=”post”，默认为 get，自己改。</li><li>请求头中 <code>Content-Type: application/x-www-form-urlencoded (key=value&amp;key=value</code>，form 中 input 的 name 为 key)</li><li>提交的内容在 Form Data 中，HTTP 不靠谱，密码为明文。英文之外的都会转义，utf-8 变长编码，英文1个字节，中文3个字节，每个字节前有 <code>%</code></li><li>如果 form 表单里没有提交按钮（input 标签，type=”submit”），则无法提交</li><li>如果1个 <code>&lt;form&gt;</code> 里面只有一个按钮(<code>&lt;button&gt;</code>)，会自动升级为提交按钮，但如果 button 标签写了 <code>type=&quot;button&quot;</code>，表单则无法提交</li></ol><h2 id="input"><a href="#input" class="headerlink" title="input"></a>input</h2><ul><li>input / button 区别：是否为「空标签」</li></ul><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/Input" target="_blank">input 的更多属性&gt;&gt;</a><br><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/button" target="_blank">button 的更多属性&gt;&gt;</a></p><table><thead><tr><th>type</th><th>说明</th></tr></thead><tbody><tr><td>button</td><td>定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。<br>和 button 标签在 form 表单中有区别，无法自动升级为提交按钮，看起来和 type=”submit” 的 input 一样</td></tr><tr><td>checkbox</td><td>定义复选框。<br>（1） id=”xxx” <code>&lt;label for=&quot;xxx&quot;&gt;你是白痴吗&lt;/label&gt;</code><br>（2） 用label 包 input ，这样就不用 id 关联，老司机推荐<br><code>&lt;label for=&quot;xxx&quot;&gt;你是白痴吗&lt;input type=&quot;checkbox&quot; name=&quot;user&quot;&gt;&lt;/label&gt;</code><br>（3） 在 form 中，checked: inputName=on, !cheked: 无内容<br>（4）多选，name 相同，value 不同，勾选的会被提交。如：<br>name=”animal”, value=[“panda”, “dog”, “fish”] // 选了前两个，Form Data: animal=panda&amp;animal=fish</td></tr><tr><td>file</td><td>定义输入字段和 “浏览”按钮，供文件上传。</td></tr><tr><td>hidden</td><td>定义隐藏的输入字段。<a href="https://blog.csdn.net/kuangruike/article/details/52127450" target="_blank" rel="noopener">https://blog.csdn.net/kuangruike/article/details/52127450</a></td></tr><tr><td>image</td><td>定义图像形式的提交按钮。</td></tr><tr><td>password</td><td>定义密码字段。该字段中的字符被掩码。只是在 html 看不见，实际上还是明文的</td></tr><tr><td>radio</td><td>定义单选按钮。similar to checkbox</td></tr><tr><td>reset</td><td>定义重置按钮。重置按钮会清除表单中的所有数据。</td></tr><tr><td>submit</td><td>定义提交按钮。提交按钮会把表单数据发送到服务器。</td></tr><tr><td>text</td><td>定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。</td></tr><tr><td>HTML5</td><td>新类型，不支持的浏览器显示为常规的文本域</td></tr><tr><td>email</td><td>要有 “@”，并且 “@” 前后都要有字符，且不能为中文（别的没试）</td></tr><tr><td>url</td><td>粗糙测试，要有 http:// or https://</td></tr><tr><td>number</td><td>能够设定对所接受的数字的限定 min=”1” max=”10”</td></tr><tr><td>range</td><td>滑动条，min max 设定范围，value 默认值，step 间隔</td></tr><tr><td>Date pickers (date, month, week, time, datetime, datetime-local)</td><td>date - 选取日、月、年<br>month - 选取月、年<br>week - 选取周和年<br>time - 选取时间（小时和分钟）<br>datetime - 选取时间、日、月、年（UTC 时间）<br>datetime-local - 选取时间、日、月、年（本地时间）</td></tr><tr><td>search</td><td>右边多个叉叉，点了清空内容</td></tr><tr><td>color</td><td>只有 Opera 支持，应该没有卵用</td></tr></tbody></table><h2 id="select-标签"><a href="#select-标签" class="headerlink" title="select 标签"></a>select 标签</h2><p>下拉选择</p><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">select</span> <span class="attr">name</span>=<span class="string">"group"</span> <span class="attr">multiple</span>&gt;</span> // multiple 可多选</span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">""</span>&gt;</span>-<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"1"</span>&gt;</span>item1<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"2"</span>&gt;</span>item2<span class="tag">&lt;/<span class="name">option</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"3"</span> <span class="attr">disabled</span>&gt;</span>item3<span class="tag">&lt;/<span class="name">option</span>&gt;</span> // disabled 不可选</span><br><span class="line">    <span class="tag">&lt;<span class="name">option</span> <span class="attr">value</span>=<span class="string">"4"</span> <span class="attr">selected</span>&gt;</span>item4<span class="tag">&lt;/<span class="name">option</span>&gt;</span> // selected 默认选中</span><br><span class="line"><span class="tag">&lt;/<span class="name">select</span>&gt;</span></span><br><span class="line"></span><br><span class="line">// 在 form 中提交格式为 selectName=selectedOptionValue</span><br></pre></td></tr></table></figure><h2 id="textarea-标签"><a href="#textarea-标签" class="headerlink" title="textarea 标签"></a>textarea 标签</h2><p>输入多行内容</p><table><thead><tr><th>需求</th><th>操作</th></tr></thead><tbody><tr><td>大小不可改变</td><td>CSS  resize: none;</td></tr><tr><td>设置大小</td><td>(CSS  width/height) or (col/rows  不准，一般不用)</td></tr></tbody></table><h2 id="table-标签示例"><a href="#table-标签示例" class="headerlink" title="table 标签示例"></a>table 标签示例</h2><p>用于展示数据</p><p><a href="https://developer.mozilla.org/zh-CN/docs/Web/HTML/Element/table" target="_blank">input 的更多属性&gt;&gt;</a></p><ol><li>HTML 规定 <code>&lt;table&gt;</code> 中只可以有3个元素：<code>&lt;thead&gt; &lt;tbody&gt; &lt;tfoot&gt;</code></li><li>tbody 标签不写，浏览器会自动补上</li><li>表格边框的间隙默认有，不要则设置 table { border-collapse: collapse; }</li></ol><figure class="highlight html"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&lt;!-- table row 行 tr --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table data 数据 td --&gt;</span></span><br><span class="line"><span class="comment">&lt;!-- table header 表头的标题 --&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="tag">&lt;<span class="name">table</span> <span class="attr">border</span>=<span class="string">1</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- colgroup 里面有元素就是有标签的元素 --&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">colgroup</span>&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- col 指定列的宽度 --&gt;</span></span><br><span class="line">        <span class="comment">&lt;!-- col 有 bgcolor 属性，设置改列的背景色 --&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">bgcolor</span>=<span class="string">red</span> <span class="attr">width</span>=<span class="string">200</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">100</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">col</span> <span class="attr">width</span>=<span class="string">70</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;/<span class="name">colgroup</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">thead</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>项目<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>姓名<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>性别<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">th</span>&gt;</span>年龄<span class="tag">&lt;/<span class="name">th</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">thead</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tbody</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>如花<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>1<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>90<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span><span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>狗蛋<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>2<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>92<span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>平均分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tbody</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;<span class="name">tfoot</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;<span class="name">tr</span>&gt;</span></span><br><span class="line">                <span class="tag">&lt;<span class="name">th</span>&gt;</span>总分<span class="tag">&lt;/<span class="name">th</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span></span><br><span class="line">            <span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">        <span class="tag">&lt;/<span class="name">tfoot</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure><h2 id="pre-标签-（preview）"><a href="#pre-标签-（preview）" class="headerlink" title="pre 标签 （preview）"></a>pre 标签 （preview）</h2><p>该标签中的文本，保留原有格式；<br><code>&lt;pre&gt;</code>标签中可以加标签</p><p><a href="http://www.w3school.com.cn/html5/html5_reference.asp" title="HTML 5 参考手册" target="_blank" rel="noopener">HTML5 新标签 完整列表&gt;&gt;</a></p>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是可替换标签(replaced element)</title>
      <link href="/2019/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><p>可替换元素的展现效果不由 CSS 控制。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。</p><p>换句话说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 <code>&lt;iframe&gt;</code> 元素，可能具有自己的样式表，但它们不会继承父文档的样式。</p><p>CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的控制内容框中的对象位置。</p><a id="more"></a><h2 id="可替换元素"><a href="#可替换元素" class="headerlink" title="可替换元素"></a>可替换元素</h2><p>典型的可替换元素有：</p><ul><li><code>&lt;iframe&gt;</code></li><li><code>&lt;video&gt;</code></li><li><code>&lt;embed&gt;</code></li><li><code>&lt;img&gt;</code></li></ul><p>有些元素仅在特定情况下被作为可替换元素处理，例如：</p><ul><li><code>&lt;option&gt;</code></li><li><code>&lt;audio&gt;</code></li><li><code>&lt;canvas&gt;</code></li><li><code>&lt;object&gt;</code></li><li><code>&lt;applet&gt;</code></li></ul><p>HTML spec also says that an <code>&lt;input&gt;</code> element can be replaced, because <code>&lt;input&gt;</code> elements of the “image” type are replaced elements similar to <code>&lt;img&gt;.</code> However, other form controls, including other types of <code>&lt;input&gt;</code> elements, are explicitly listed as non-replaced elements (the spec describes their default platform-specific rendering with the term “Widgets”).</p><p>Objects inserted using the CSS content property are anonymous replaced elements. They are “anonymous” because they don’t exist in the HTML markup.</p><ul><li><code>&lt;input&gt;</code> 元素在 type 为 “image” 时为可替换标签，类似于 <code>&lt;img&gt;</code> 元素</li><li>使用 CSS 的 content 属性插入的对象是 <code>匿名可替换元素</code>，因为它们不是 HTML 标签，如：before、after</li></ul><p>表示不知道 markup 是啥，搜了下</p><p>Markup is a symbol or character that you insert at certain place in a text file. This represents how the file should look (bold, italic, link, etc) when it is printed in your browser.<br>Also the markup indicators are often called “tags.”</p><ul><li>HTML markup 俗称标签</li></ul><h2 id="CSS-与可替换元素"><a href="#CSS-与可替换元素" class="headerlink" title="CSS 与可替换元素"></a>CSS 与可替换元素</h2><p>CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值。</p><p>需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align。会只有可替换元素才能具有这种自带值。</p><h3 id="控制内容框中的对象位置"><a href="#控制内容框中的对象位置" class="headerlink" title="控制内容框中的对象位置"></a>控制内容框中的对象位置</h3><p>某些CSS属性可用于指定被替换元素中包含的对象应如何定位在元素的框区域中。这些由CSS图像模块3级和CSS图像模块4级规范定义：</p><ul><li>object-fit</li></ul><p>Specifies how the replaced element’s content object should be fitted to the containing element’s box.</p><ul><li>object-position</li></ul><p>Specifies the alignment of the replaced element’s content object within the element’s box.</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ol><li>典型的：<code>&lt;iframe&gt;</code>、<code>&lt;video&gt;</code>、<code>&lt;embed&gt;</code>、<code>&lt;img&gt;</code>，仅在特定情况下为可替换元素：<code>&lt;option&gt;</code>、<code>&lt;audio&gt;</code>、<code>&lt;canvas&gt;</code>、<code>&lt;object&gt;</code>、<code>&lt;applet&gt;</code>、<code>&lt;input&gt;</code>；</li><li>很多属性不受 CSS 控制；</li><li>使用 CSS 的 content 属性插入的对象是一个 anonymous replaced element（:before、:after）；</li><li>CSS 对 replaced element 的一些计算会特殊处理，如 margin 和一些 auto 值；</li><li>有些（不是所有）的 replaced element 会有自己固有的尺寸，或用于 vertical-align 等属性的 baseline</li></ol><blockquote><p>「it is best to read “replaced” as “embedding”」这句话，很好地阐述了什么是 replaced element：它的内容是嵌入进来的。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>什么是空标签（empty element）</title>
      <link href="/2019/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E6%A0%87%E7%AD%BE/"/>
      <url>/2019/02/25/%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E6%A0%87%E7%AD%BE/</url>
      
        <content type="html"><![CDATA[<h2 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h2><ul><li>空元素是指来自 HTML，SVG 或 MathML 中，不具有任何子节点（即嵌套元素或文本节点）的元素。</li><li>HTML，SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 <code>&lt;audio&gt;</code> 元素嵌套在一个 <code>&lt;hr&gt;</code> 元素里。</li><li>在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， <code>&lt;input type=&quot;text&quot;&gt;&lt;/input&gt;</code> 的闭标签是无效的 HTML。</li></ul><blockquote><p>总结：不需要成对出现的标签</p></blockquote><a id="more"></a><h2 id="在-HTML-中有以下这些空元素"><a href="#在-HTML-中有以下这些空元素" class="headerlink" title="在 HTML 中有以下这些空元素"></a>在 HTML 中有以下这些空元素</h2><ul><li><code>&lt;area&gt;</code></li><li><code>&lt;base&gt;</code></li><li><code>&lt;br&gt;</code></li><li><code>&lt;col&gt;</code></li><li><code>&lt;colgroup&gt;</code> when the span is present</li><li><code>&lt;command&gt;</code></li><li><code>&lt;embed&gt;</code></li><li><code>&lt;hr&gt;</code></li><li><code>&lt;img&gt;</code></li><li><code>&lt;input&gt;</code></li><li><code>&lt;keygen&gt;</code> （HTML 5.2 草案已删除）</li><li><code>&lt;link&gt;</code></li><li><code>&lt;meta&gt;</code></li><li><code>&lt;param&gt;</code></li><li><code>&lt;source&gt;</code></li><li><code>&lt;track&gt;</code></li><li><code>&lt;wbr&gt;</code></li></ul><blockquote><p>Note: 在极少数情况下，空元素被错误地称为“无效元素”(void elements)。</p></blockquote>]]></content>
      
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP</title>
      <link href="/2019/02/24/HTTP/"/>
      <url>/2019/02/24/HTTP/</url>
      
        <content type="html"><![CDATA[<h2 id="HTTP-请求"><a href="#HTTP-请求" class="headerlink" title="HTTP 请求"></a>HTTP 请求</h2><h3 id="请求示例"><a href="#请求示例" class="headerlink" title="请求示例"></a>请求示例</h3><p>命令 </p><p><code>curl -s -v -H &quot;aaa: bbb&quot; -- &quot;https://www.baidu.com&quot;</code></p><p>请求的内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">GET / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">aaa: bbb</span><br></pre></td></tr></table></figure><a id="more"></a><p>命令</p><p><code>curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Celeste: xxx&quot; -- &quot;https://www.baidu.com&quot;</code></p><p>请求的内容为</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">POST / HTTP/1.1</span><br><span class="line">Host: www.baidu.com</span><br><span class="line">User-Agent: curl/7.54.0</span><br><span class="line">Accept: */*</span><br><span class="line">Celeste: xxx</span><br><span class="line">Content-Length: 10</span><br><span class="line">Content-Type: application/x-www-form-urlencoded</span><br><span class="line"></span><br><span class="line">1234567890</span><br></pre></td></tr></table></figure><h3 id="请求的格式"><a href="#请求的格式" class="headerlink" title="请求的格式"></a>请求的格式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">1 动词 路径 协议/版本</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Key3: value3</span><br><span class="line">2 Content-Type: application/x-www-form-urlencoded</span><br><span class="line">2 Host: www.baidu.com</span><br><span class="line">2 User-Agent: curl/7.54.0</span><br><span class="line"><span class="number">3</span> </span><br><span class="line">4 要上传的数据</span><br></pre></td></tr></table></figure><ol><li>请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空）</li><li>第三部分永远都是一个回车（\n）</li><li>动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等</li><li>这里的路径包括「查询参数」，但不包括「锚点」</li><li>如果你没有写路径，那么路径默认为 /</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li></ol><h3 id="用-Chrome-发请求"><a href="#用-Chrome-发请求" class="headerlink" title="用 Chrome 发请求"></a>用 Chrome 发请求</h3><ol><li>打开 Network</li><li>地址栏输入网址</li><li>在 Network 点击，查看 request，点击「view source」</li><li>如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到</li></ol><h2 id="HTTP-响应"><a href="#HTTP-响应" class="headerlink" title="HTTP 响应"></a>HTTP 响应</h2><h3 id="响应示例"><a href="#响应示例" class="headerlink" title="响应示例"></a>响应示例</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">HTTP/1.1 200 OK</span><br><span class="line">Accept-Ranges: bytes</span><br><span class="line">Cache-Control: private, no-cache, no-store, proxy-revalidate, no-transform</span><br><span class="line">Connection: Keep-Alive</span><br><span class="line">Content-Length: 2443</span><br><span class="line">Content-Type: text/html</span><br><span class="line">Date: Sun, 24 Feb 2019 05:55:32 GMT</span><br><span class="line">Etag: "58860421-98b"</span><br><span class="line">Last-Modified: Mon, 23 Jan 2017 13:24:49 GMT</span><br><span class="line">Pragma: no-cache</span><br><span class="line">Server: bfe/1.0.8.18</span><br><span class="line">Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/</span><br><span class="line"></span><br><span class="line">&lt;!DOCTYPE html&gt;</span><br><span class="line">&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 省略</span><br></pre></td></tr></table></figure><ul><li>GET 请求和 POST 请求对应的响应可以一样，也可以不一样</li><li>响应的第四部分可以很长很长很长</li></ul><h3 id="响应的格式"><a href="#响应的格式" class="headerlink" title="响应的格式"></a>响应的格式</h3><figure class="highlight"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">1 协议/版本号 状态码 状态解释</span><br><span class="line">2 Key1: value1</span><br><span class="line">2 Key2: value2</span><br><span class="line">2 Content-Length: 17931</span><br><span class="line">2 Content-Type: text/html</span><br><span class="line"><span class="number">3</span></span><br><span class="line">4 要下载的内容</span><br></pre></td></tr></table></figure><ul><li>状态码要背，是服务器对浏览器说的话<ul><li>1xx 不常用</li><li>2xx 表示成功</li><li>3xx 表示滚吧</li><li>4xx 表示客户端出错</li><li>5xx 表示服务器出错</li></ul></li><li>状态解释没什么用</li><li>第 2 部分中的 Content-Type 标注了第 4 部分的格式</li><li>第 2 部分中的 Content-Type 遵循 MIME 规范</li></ul><h3 id="用-Chrome-查看响应"><a href="#用-Chrome-查看响应" class="headerlink" title="用 Chrome 查看响应"></a>用 Chrome 查看响应</h3><ol><li>打开 Network</li><li>输入网址</li><li>选中第一个响应</li><li>查看 Response Headers，点击「view source」</li><li>你会看到响应的前两部分</li><li>查看 Response 或者 Preview，你会看到响应的第 4 部分</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> HTTP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git入门</title>
      <link href="/2019/02/22/git%E5%85%A5%E9%97%A8/"/>
      <url>/2019/02/22/git%E5%85%A5%E9%97%A8/</url>
      
        <content type="html"><![CDATA[<h3 id="git-init"><a href="#git-init" class="headerlink" title="git init"></a>git init</h3><ul><li>运行”mkdir 目录名”，创建项目目录</li><li>运行”cd 目录名”，进入项目目录</li><li>运行”git init”，在当前工作目录创建一个空的 git 仓库，会生成一个 .git 隐藏目录</li><li>使用 tree 命令可以查看 .git 目录，其中 HEAD 为指向 master 的指针<a id="more"></a></li></ul><p><img src="//raw.githubusercontent.com/CelesteWeng/images/master/gitInit.jpeg" alt="gitAdd.jpeg"></p><h3 id="git-add"><a href="#git-add" class="headerlink" title="git add"></a>git add</h3><ul><li>工作区的文件发生变化后，使用 git add 命令按需求添加到暂存区（index）</li><li>此时查看 .git 目录，相比执行完 git init 时，多了 index 文件，objects 目录也增加了 b1 子目录</li><li>大批量的操作文件时，可使用参数 -A -U，或 git add .</li></ul><p><img src="//raw.githubusercontent.com/CelesteWeng/images/master/gitAdd.jpeg" alt="gitAdd.jpeg"></p><h3 id="git-commit-v"><a href="#git-commit-v" class="headerlink" title="git commit -v"></a>git commit -v</h3><ul><li>当暂存区有内容时，执行该命令会进入 vim ，罗列未跟踪的文件和已提交的文件，同时展示已提交的文件相比之前的改动</li><li>执行过 git commit 命令后，.git 目录中会增加 COMMIT_EDITMSG 文件</li><li>git commit -m “提交信息” 可提交暂存区文件</li></ul><p><img src="//raw.githubusercontent.com/CelesteWeng/images/master/gcv.jpeg" alt="gcv.jpeg"></p><p><img src="//raw.githubusercontent.com/CelesteWeng/images/master/gcv2.png" alt="gcv2.png"></p>]]></content>
      
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
            <tag> git </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用命令及查询</title>
      <link href="/2019/02/21/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/"/>
      <url>/2019/02/21/%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h2 id="ls"><a href="#ls" class="headerlink" title="ls"></a>ls</h2><p><code>list directory contents</code> 罗列指定目录（或当前工作目录）中的子目录和文件</p><p><strong>用法</strong>：ls [-alrtAFR] [name…]</p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-a</td><td>显示所有的文件，包括以”.”开头的隐藏文件</td></tr><tr><td>-l</td><td>不仅显示文件名，还罗列了文件型态、权限、所有者、文件大小、更新时间等信息</td></tr><tr><td>-r</td><td>将文件以相反次序显示(原定依英文字母次序)</td></tr><tr><td>-t</td><td>将文件依建立时间之先后次序列出</td></tr><tr><td>-A</td><td>同 -a，但不列出 “.” (目前目录) 及 “..” (父目录)</td></tr><tr><td>-F</td><td>在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“</td></tr><tr><td>-R</td><td>若目录下有文件，则以下之文件亦皆依序列出</td></tr></tbody></table>   <a id="more"></a><p> 参数可叠加使用：ls -la 路径</p><h2 id="cat"><a href="#cat" class="headerlink" title="cat"></a>cat</h2><p> <code>concatenate files and print on the standard output</code> 连接文件并打印到标准输出设备上</p><p><strong>语法格式</strong>：cat [-AbeEnstTuv] [–help] [–version] fileName </p><table><thead><tr><th>参数</th><th>功能</th></tr></thead><tbody><tr><td>-n 或 –number</td><td>由 1 开始对所有输出的行数编号</td></tr><tr><td>-b 或 –number-nonblank</td><td>和 -n 相似，只不过对于空白行不编号</td></tr><tr><td>-s 或 –squeeze-blank</td><td>当遇到有连续两行以上的空白行，就代换为一行的空白行</td></tr><tr><td>-v 或 –show-nonprinting</td><td>使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外</td></tr><tr><td>-E 或 –show-ends</td><td>在每行结束处显示 $</td></tr><tr><td>-T 或 –show-tabs</td><td>将 TAB 字符显示为 ^I</td></tr><tr><td>-A, –show-all</td><td>等价于 -vET</td></tr><tr><td>-e</td><td>等价于”-vE”选项</td></tr><tr><td>-t</td><td>等价于”-vT”选项</td></tr></tbody></table><h2 id="mv"><a href="#mv" class="headerlink" title="mv"></a>mv</h2><p> <code>move (rename) files</code> 移动文件或目录到指定路径、重命名文件或目录</p><p><strong>语法格式</strong>：</p><ul><li>mv [options] source dest</li><li>mv [options] source… directory</li></ul><table><thead><tr><th>命令格式</th><th>运行结果</th></tr></thead><tbody><tr><td>mv 文件名 文件名</td><td>将源文件名改为指定文件名</td></tr><tr><td>mv 文件名 目录名</td><td>将文件移动到指定目录</td></tr><tr><td>mv 目录名 目录名</td><td>目标目录存在，将源目录移动到目标目录；目标目录不存在，源目录名改为指定目录名</td></tr><tr><td>mv 目录名 文件名</td><td>报错</td></tr></tbody></table><h2 id="touch"><a href="#touch" class="headerlink" title="touch"></a>touch</h2><p> <code>change file timestamps</code> 修改文件或目录的时间属性（读取时间、更改时间），文件不存在则创建一个新文件</p><p><strong>语法格式</strong>：touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…]</p><p>这个参数感觉没什么卵用。。</p><h2 id="如何使用-explainshell-com"><a href="#如何使用-explainshell-com" class="headerlink" title="如何使用 explainshell.com"></a>如何使用 explainshell.com</h2><ul><li>把命令输进 input 查询，可以移动鼠标分别查看命令和参数的释义</li><li>点击结果中命令名，可以查看所有参数及其释义</li><li>点击命令名左侧向下箭头，可以切换查看命令在其他手册中的释义</li></ul>]]></content>
      
      
      
        <tags>
            
            <tag> 命令行 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>对创建对象方法的理解</title>
      <link href="/2019/01/24/%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/"/>
      <url>/2019/01/24/%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h3 id="1-创建-Object-对象的实例或通过对象字面量定义。"><a href="#1-创建-Object-对象的实例或通过对象字面量定义。" class="headerlink" title="1. 创建 Object 对象的实例或通过对象字面量定义。"></a>1. 创建 Object 对象的实例或通过对象字面量定义。</h3><p>缺点：大量重复代码。</p><h3 id="2-工厂模式"><a href="#2-工厂模式" class="headerlink" title="2. 工厂模式"></a>2. 工厂模式</h3><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">var</span> o = <span class="keyword">new</span> <span class="built_in">Object</span>();</span><br><span class="line">  o.name = name;</span><br><span class="line">  o.age = age;</span><br><span class="line">  o.job = job;</span><br><span class="line">  o.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;;</span><br><span class="line">  <span class="keyword">return</span> o; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = createPerson(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = createPerson(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>解决了创建 多个相似对象的问题。在函数中定义对象，return 语句返回对象，通过调用函数创建对象。</p><p>缺点：书中说是无法识别对象的类型，但实际上创建出的对象变量可通过 constructor 属性判断（person1.constructor === Array），constructor 准确，instanceof 有误差</p><hr><p>经试验，在函数中通过构造函数创建对象，则对象的 constructor 属性是准确的。<br>如果是用 <code>Object 构造函数</code>创建，只有 obj instanceof Object 为 true；<br>若是 <code>Array 构造函数</code>创建，不仅<br>alert(obj instanceof Object); //  true，<br>同时<br>alert(obj instanceof Array); //  true</p><p>本人觉得工厂模式，硬是要判断也是可以判断的。<br>书中的意思：</p><ul><li>可能一：<br>直接拿函数来判断，则无法判断函数内定义了哪种对象。</li><li>可能二：<br>自定义的构造函数创建对象，对象即构造函数的实例，相当于这个对                    象的类别就是自定义的构造函数，直观，同时也是 Object 的实例。</li></ul><h2 id="3-构造函数模式"><a href="#3-构造函数模式" class="headerlink" title="3. 构造函数模式"></a>3. 构造函数模式</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.name = name;</span><br><span class="line">  <span class="keyword">this</span>.age = age;</span><br><span class="line">  <span class="keyword">this</span>.job = job;</span><br><span class="line">  <span class="keyword">this</span>.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">      alert(<span class="keyword">this</span>.name);</span><br><span class="line">  &#125;; </span><br><span class="line">&#125; </span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><ul><li>和工厂模式的区别：没有显式地创建对象；直接将属性和方法赋给了 this 对象；没有 return 语句。</li><li>构造函数以大写字母开头</li><li>使用 new 操作符创建自定义构造函数的实例，经历的步骤：<br>（1）创建一个新对象；<br>（2）将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；<br>（3）执行构造函数中的代码（为这个新对象添加属性）；<br>（4）返回新对象。</li><li>对象的 constructor（构造函数） 属性：最初用来标识对象类型，但还是 instanceof 操作符更为靠谱。在上例中创建的对象既是 Object 的实例，也是 Person 的实例。</li></ul><ol><li><strong>将构造函数当做函数</strong><br>（1）使用 new 操作符当做构造函数使用；<br>（2）作为普通函数调用：this 对象会只想 Global 对象；<br>（3）在另一个对象的作用域中调用（改变 this 指向，apply\call）</li><li><strong>构造函数的问题</strong></li></ol><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name, age, job</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.name = name;</span><br><span class="line">    <span class="keyword">this</span>.age = age;</span><br><span class="line">    <span class="keyword">this</span>.job = job;</span><br><span class="line">    **<span class="keyword">this</span>.sayName = sayName;**</span><br><span class="line">&#125; </span><br><span class="line">**<span class="function"><span class="keyword">function</span> <span class="title">sayName</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125; **</span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person(<span class="string">"Nicholas"</span>, <span class="number">29</span>, <span class="string">"Software Engineer"</span>);</span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person(<span class="string">"Greg"</span>, <span class="number">27</span>, <span class="string">"Doctor"</span>);</span><br></pre></td></tr></table></figure><p>  上述代码将函数定义在了构造函数外部，这样创建多个 Person 的实例时，就不会创建多个功能相同的 Function 实例了。</p><p>  但是在全局作用域中定义的函数实际上只能被某个对象调用。更重要的是：如果对象需要定义很多方法，那就需要定义很多全局函数，没有封装性。-&gt; but，可通过使用原型模式解决。</p><hr><p>构造函数模式个人小总结：</p><p>相对工厂模式，不显示地创建对象，使用 this 对象，同时没有 return 语句。解决了对象类别的识别问题。</p><p>可优化点：将对象的方法定义在全局，避免创建功能相同的 Function 的实例。但是在想要为对象添加很多方法时，就需要在全局声明很多函数，封装性不好。</p><p>缺点（将对象的方法声明在全局后，仍存在的问题）：全局函数实际上只能被某个对象调用。</p><h3 id="4-原型模式"><a href="#4-原型模式" class="headerlink" title="4. 原型模式"></a>4. 原型模式</h3><p>每个函数都有 prototype（原型）属性，该属性是一个指针，指向一个对象（原型对象），这个对象的用途是：包含 可以被 特定类型（本人理解：相当于构造函数，JS中没有类）的所有实例共享的属性和方法。</p><p>即在原型对象中定义对象实例的信息，而不必在构造函数中定义。</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params"></span>)</span>&#123;&#125;</span><br><span class="line"></span><br><span class="line">Person.prototype.name = <span class="string">"Nicholas"</span>;</span><br><span class="line">Person.prototype.age = <span class="number">29</span>;</span><br><span class="line">Person.prototype.job = <span class="string">"Software Engineer"</span>;</span><br><span class="line">Person.prototype.sayName = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    alert(<span class="keyword">this</span>.name);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> person1 = <span class="keyword">new</span> Person();</span><br><span class="line">person1.sayName();   <span class="comment">//"Nicholas"</span></span><br><span class="line"><span class="keyword">var</span> person2 = <span class="keyword">new</span> Person();</span><br></pre></td></tr></table></figure><hr><p>原型模式个人小总结：</p><p>在函数的 prototype 属性中定义对象的属性和方法，可以被构造函数的实例共用。解决了构造函数模式 将 对象的方法声明在全局后，不能被多个实例共用的问题。</p>]]></content>
      
      
      
        <tags>
            
            <tag> 创建对象 </tag>
            
            <tag> 工厂模式 </tag>
            
            <tag> 构造函数模式 </tag>
            
            <tag> 原型模式 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>DOM事件类</title>
      <link href="/2017/10/29/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/"/>
      <url>/2017/10/29/dom%E4%BA%8B%E4%BB%B6%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h2 id="一、基本概念：DOM事件的级别"><a href="#一、基本概念：DOM事件的级别" class="headerlink" title="一、基本概念：DOM事件的级别"></a>一、基本概念：DOM事件的级别</h2><ul><li>事件级别（DOM标准定义的级别）</li><li>DOM0 element.onclick = function(){} // 在 DOM1 标准产生之前就存在的事实规范</li><li>DOM2 element.addEventListener(‘click’,function(){},false)</li><li>默认false，冒泡；true为捕获。</li><li>DOM3 element.addEventListener(‘keyup’,function(){},false)</li><li>DOM1标准并非不存在，只是没有涉及和事件相关的东西</li></ul><a id="more"></a><h2 id="二、DOM事件模型"><a href="#二、DOM事件模型" class="headerlink" title="二、DOM事件模型"></a>二、DOM事件模型</h2><p>捕获：从上往下<br>冒泡：从下往上</p><h2 id="三、DOM事件流"><a href="#三、DOM事件流" class="headerlink" title="三、DOM事件流"></a>三、DOM事件流</h2><ul><li><p>浏览器为当前页面与用户做交互（如点击鼠标左键）的过程中，左键传到页面上，然后给出响应。</p></li><li><p>三个阶段</p><ol><li>捕获</li><li>目标阶段：事件通过捕获到达目标元素（如：点击的那个按钮，就为目标阶段）</li><li>冒泡：从目标元素上传到window对象</li></ol></li></ul><h2 id="四、描述DOM事件捕获的具体流程"><a href="#四、描述DOM事件捕获的具体流程" class="headerlink" title="四、描述DOM事件捕获的具体流程"></a>四、描述DOM事件捕获的具体流程</h2><ul><li>接收事件的顺序<ol><li>window</li><li>document</li><li>html(扩展：如何获取当前页面的html节点：document.documentElement)</li><li>body</li><li>…</li><li>最终：目标元素</li></ol></li><li>冒泡则反向回去</li></ul><h2 id="五、Event对象的常见应用"><a href="#五、Event对象的常见应用" class="headerlink" title="五、Event对象的常见应用"></a>五、Event对象的常见应用</h2><ul><li>简介：拿用户交互的参数，比如想知道按了哪个键，鼠标点了哪个键，基本都是从Event对象拿来的。</li><li>易混淆的5项：<ol><li>event.preventDefault() —- 阻止默认事件</li><li>event.stopPropagation() —- 阻止冒泡</li><li>event.stopImmediatePropagation()<br> 例：一个按钮，绑定2个事件，响应函数a、响应函数b，通过++优先级++的方式，若a被点击，b不执行，就要用到该语句，在函数a中加入该语句。</li><li>event.currentTarget —-指向事件所绑定的元素（即事件委托中的父级）</li><li>event.target —-始终指向事件发生时的元素</li></ol></li><li>知识前提：<br>  事件委托：把子元素的事件都委托到父元素上，绑定一次事件即可。做响应时，要判断当前是哪个元素被点击，就要用到target。</li></ul><h2 id="六、自定义事件"><a href="#六、自定义事件" class="headerlink" title="六、自定义事件"></a>六、自定义事件</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> eve = <span class="keyword">new</span> Event(<span class="string">'custome'</span>);</span><br><span class="line">ev.addEventListener(<span class="string">'custome'</span>, <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'custome'</span>);</span><br><span class="line">&#125;);</span><br><span class="line">ev.ispatchEvent(eve); <span class="comment">//触发eve对象</span></span><br></pre></td></tr></table></figure><ul><li>CustomEvent和Event区别：CustomEvent还可以绑定obj参数，在用法上，两者一致。</li></ul><h2 id="七、其他"><a href="#七、其他" class="headerlink" title="七、其他"></a>七、其他</h2><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">print</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'hi'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">onclick=&quot;要执行的代码&quot;</span><br><span class="line">一旦用户点击，浏览器就 `eval(&quot;要执行的代码&quot;)`</span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">xxx.onclick = print // 等号两边都为事件</span><br><span class="line">// 写为 print() 为 undefined</span><br></pre></td></tr></table></figure><hr><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">xxx.onclick = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 属性，唯一，只能有一个点击事件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 队列，先进先出，可以监听多个点击事件</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="number">1</span>)</span><br><span class="line">    <span class="comment">// xxx.removeEventListener('click', f1()), one, 只执行一次</span></span><br><span class="line">&#125;</span><br><span class="line">xxx.addEventListener(<span class="string">'click'</span>, f1())</span><br></pre></td></tr></table></figure><hr><p><img src="http://pntmc1hcw.bkt.clouddn.com/capture.png" alt="capture.png"><br>最后的子元素同时有捕获和冒泡，则看代码写的顺序执行；<br>一般为先捕获，后冒泡。</p><hr><p>用户有没有看当前页面(自动轮播时，bug，不看该页面时，定时器会偷懒)</p><figure class="highlight js"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">document</span>.addEventListener(<span class="string">'visbilitychange'</span>, <span class="function"><span class="keyword">function</span>(<span class="params">e</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="built_in">document</span>.hidden)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>]]></content>
      
      
      
        <tags>
            
            <tag> DOM </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
