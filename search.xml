<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[JS题目总结（原型链、new、JSON、MVC、Promise）]]></title>
    <url>%2F2019%2F03%2F19%2FJS%E9%A2%98%E7%9B%AE%E6%80%BB%E7%BB%93%EF%BC%88%E5%8E%9F%E5%9E%8B%E9%93%BE%E3%80%81new%E3%80%81JSON%E3%80%81MVC%E3%80%81Promise%EF%BC%89%2F</url>
    <content type="text"><![CDATA[第一题123456789101112131415161718var object = &#123;&#125;object.__proto__ === Object.prototype // 为 truevar fn = function() &#123;&#125;fn.__proto__ === Function.prototype // 为 truefn.__proto__.__proto__ === Object.prototype // 为 truevar array = []array.__proto__ === Array.prototype // 为 truearray.__proto__.__proto__ === Object.prototype // 为 trueFunction.__proto__ === Function.prototype // 为 trueArray.__proto__ === Function.prototype // 为 trueObject.__proto__ === Function.prototype // 为 truetrue.__proto__ === Boolean.prototype // 为 trueFunction.prototype.__proto__ === Object.prototype // 为 true 第二题1234function fn() &#123; console.log(this)&#125;new fn() new fn() 会执行 fn，并打印出 this，请问这个 this 有哪些属性？这个 this 的原型有哪些属性？ 答：this 为构造函数 fn 的一个实例，有内置属性 [[Prototype]]，在部分浏览器中表现为 __proto__ 属性；this.__proto__ === fn.prototype // true，this 的原型的属性有 constructor、__proto__。 12345678// 换成这样做function fn() &#123; console.log(this)&#125;var f1 = new fn()console.log('(f1.__proto__ === fn.prototype) =&gt;', f1.__proto__ === fn.prototype)console.log(f1)console.log(f1.__proto__) 第三题JSON vs JS =&gt; 博客-发送请求.md 第四题 前端 MVC 是什么？ 答：MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller) 模型：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作. 视图：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。 控制器：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。 请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。 123456/*View('.xxx')*/window.View = function (selector) &#123; return document.querySelector(selector)&#125; 12345678910111213/*Model(&#123; 'resourceName': xxx&#125;)*/window.Model = function(object) &#123; let resourceName = object.resourceName return &#123; init: function() &#123;&#125;, fetch: function() &#123;&#125;, save: function(object) &#123;&#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/*Controller(&#123; init: function(view, model) &#123; this.view = xxx this.model = xxx this.xxx() this.yyy() &#125;, xxx: function() &#123;&#125;, yyy: function() &#123;&#125;&#125;)*/window.Controller = function(options) &#123; let init = options.init let object = &#123; view: null, model: null, init: function(view, model) &#123; this.view = view this.model = model this.model.init() init.call(this, view, model) // this.bindEvents.call(this) &#125; &#125; for (let key in options) &#123; if (key !== 'init') &#123; object[key] = options[key] &#125; &#125; return object&#125; 第五题如何在 ES5 中如何用函数模拟一个类？（10分） 答：使用原型对象，构造函数，new来模拟类。 将公共属性放到原型对象里，并且将构造函数的prototype属性指向原型对象。私有属性(自有属性)放到构造函数里去定义。将实例化的对象的proto指向原型对象。这样当构造函数创建一个实例化的对象的时候，就即拥有自己的私有变量和方法，也有公有的变量和方法了，实例化出来的对象的私有方法和变量修改都不会互相有影响，只有在修改公有的变量和方法的时候是对所有实例生效的。 12345function Dessert(name) &#123; this.name = name&#125;Dessert.prototype.calorie = function() &#123;&#125;let dessert = new Dessert('iceCream') 上面代码就是一个最简单的类，Dessert 构造函数创建出来的对象自身有 name 属性，其原型上面有一个 calorie 属性。 第六题用过 Promise 吗？举例说明。如果要你创建一个返回 Promise 对象的函数，你会怎么写？举例说明。 答：用过，调用后端接口对获取到的数据进行处理、自己模仿 jQuery 封装 Ajax、MVC 中 Model 的 fetch 属性和 save 属性返回 Promise 对象； 1234567891011121314/*** yyy().then(successFn, failFn)*/function yyy() &#123; return new Promise(function(resolve, reject) &#123; if (success) &#123; resolve.call(undefined, ...zzz) &#125; else if (fail) &#123; reject.call(undefined, ...qqq) &#125; &#125;)&#125;]]></content>
      <tags>
        <tag>原型链</tag>
        <tag>new</tag>
        <tag>JSON</tag>
        <tag>MVC</tag>
        <tag>Promise</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无分类笔记-2（逻辑与或、命名空间、this、new、异步）]]></title>
    <url>%2F2019%2F03%2F18%2F%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0-2%EF%BC%88%E9%80%BB%E8%BE%91%E4%B8%8E%E6%88%96%E3%80%81%E5%91%BD%E5%90%8D%E7%A9%BA%E9%97%B4%E3%80%81this%E3%80%81new%EF%BC%89%2F</url>
    <content type="text"><![CDATA[面相对象编程吧逻辑与或&amp;&amp;有假的，返回第一个 falsy 值，遇到 falsy 值就不往后判断了；全是真的，返回最后一个 truy 值。 falsy值：0、NaN、null、undefined、&quot;&quot;、false. ||有真的，返回第一个 truy 值，遇到 truy 值就中断；全是假的，返回最后一个 falsy 值。 命名空间命名空间（Namespace），也称名称空间等，它表示着一个标识符（identifier）的可见范围。 一个标识符可在多个命名空间中定义，它在不同命名空间中的含义是互不相干的。 (e.g., window.jQuery、电脑中的文件夹) thiselement.onclick = functionRef; 在函数内，this 是触发当前事件的元素。 new 异步、回调异步：【不等结果】直接执行下一步。如何拿到结果 =&gt; 回调可以拿到异步的结果 【回调是拿到异步结果的一种方式】【回调也可以拿到同步结果】]]></content>
      <tags>
        <tag>new</tag>
        <tag>逻辑与或</tag>
        <tag>命名空间</tag>
        <tag>this</tag>
        <tag>异步、回调</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[无分类笔记（解构赋值、立即执行函数、闭包、MVC、Promise）]]></title>
    <url>%2F2019%2F03%2F16%2F%E6%97%A0%E5%88%86%E7%B1%BB%E7%AC%94%E8%AE%B0%EF%BC%88%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%E3%80%81%E7%AB%8B%E5%8D%B3%E6%89%A7%E8%A1%8C%E5%87%BD%E6%95%B0%E3%80%81%E9%97%AD%E5%8C%85%E3%80%81MVC%E3%80%81Promise%EF%BC%89%2F</url>
    <content type="text"><![CDATA[ES6 解构赋值123var fn = function(options) &#123; let &#123; url, method, body &#125; = options&#125; 从作为函数实参的对象中提取数据 1234// 直接将第一个参数解构并声明，相当于用 let 声明var fn = function(&#123;url, method, body&#125;)&#123; ...&#125; 交换变量的值 1234var a = 'a'var b = 'b'[a, b] = [b, a] 其余功能：加()免声明（要在语句前加;）、修改属性名、忽略某个值（用,分割，空出下标对应项）、...rest剩余项赋值给一个变量、设置默认值（等号左边用=，等号右边用:） 解构赋值–MDN Promise 的意义 不用取名字。不用去记参数名，直接在 .then()中写，第一个参数为成功的回调，第二个参数为失败的回调。 .then可以对一个状态进行多次处理 jQuery.ajax中 responseText (“Content-Type”: “text/json”)，会自动转化为对象。 封装 jQuery.ajax 1234567window.jQuery = function(nodesOrSelector) &#123; let nodes = &#123;&#125; nodes.addClass = function() &#123;&#125; node.textContent = function() &#123;&#125; return nodes&#125;window.$ = window.jQuery 123456789101112131415161718window.jQuery.ajax = function(&#123;url, method, headers, body, success, fail&#125;)&#123; let request = new XMLHttpRequest() request.open(method, url) for(let key in headers) &#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123; success.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; fail.call(undefined, request) &#125; &#125; &#125; request.send()&#125; 1234567891011121314151617181920function doSthIfSuccess(responseText) &#123; // ...&#125;myButton.addEventListener('click', (e) =&gt; &#123; $.ajax(&#123; url: '/xxx', method: 'get', headers: &#123; 'Content-ype': 'application/x-www-form-urlencoded', 'Name': 'Celeste' &#125;, success: (responseText) =&gt; &#123; doSthIfSuccess.call(undefined, responseText) &#125;, fail: (response) =&gt; &#123; console.log(response, response.status, response.responseText) &#125; &#125;)&#125;) 123456789101112131415161718192021// 自己封装 jQuery.ajax 满足 Promise 规则window.jQuery.ajax = function(&#123; url, method, body, headers &#125;) &#123; return new Promise(function(resolve, reject) &#123; let request = new XMLHttpRequest() request.open(method, url) for (let key in headers) &#123; let value = headers[key] request.setRequestHeader(key, value) &#125; request.onreadystatechange = () =&gt; &#123; if (request.readyState === 4) &#123; if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123; resolve.call(undefined, request.responseText) &#125; else if (request.status &gt;= 400) &#123; reject.call(undefined, request) &#125; &#125; request.send() &#125; &#125;)&#125; 123456789101112131415161718192021222324252627282930myButton.addEventListener('click', (e) =&gt; &#123; let promise = jQuery.ajax(&#123; url: '/xxx', method: 'get', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Name': 'Alice' &#125; &#125;) promise.then( (text) =&gt; &#123; console.log(text) &#125;, (request) =&gt; &#123; console.log(request) &#125; )&#125;)// 上述代码相当于myButton.addEventListener('click', (e) =&gt; &#123; jQuery.ajax(&#123; url: '/xxx', method: 'get', headers: &#123; 'Content-Type': 'application/x-www-form-urlencoded', 'Name': 'Alice' &#125; &#125;).then( (text) =&gt; &#123; console.log(text) &#125;, (request) =&gt; &#123; console.log(request) &#125; )&#125;) 如何使用立即执行函数 我们不想要全局变量 我们要使用局部变量 ES 5 里面，只有函数有局部变量 于是我们声明一个 function xxx，然后 xxx.call() 这个时候 xxx 是全局变量（全局函数） 所以我们不能给这个函数名字 function(){}.call() 但是 Chrome 报错，语法错误 试出来一种方法可以不报错:i. !function(){}.call() (我们不在乎这个匿名函数的返回值，所以加个 ! 取反没关系)ii. (function(){}).call() 方方不推荐 xxx (function(){}).call() 报错iii. frank192837192463981273912873098127912378.call() 不推荐 如何使用闭包12345678910!function()&#123; var person = &#123; name: 'xiaoming', age: 3 &#125; window.personGrowUp = function()&#123; person.age += 1 return person.age &#125;&#125;.call() 1234567891011121314var accessor = function() &#123; // accessor 为 返回匿名函数 的 匿名函数 var person = &#123; name: 'xiaoming', age: 3 &#125; return function()&#123; person.age += 1 return person.age &#125;&#125;var growUp = accessor.call() // growUp 为函数growUp.call() 立即执行函数使得 person 无法被外部访问 闭包使得匿名函数可以操作 person window.frankGrowUp 保存了匿名函数的地址 任何地方都可以使用 window.frankGrowUp=&gt; 任何地方都可以使用 window.frankGrowUp 操作 person，但是不能直接访问 person 12345678910// MVC的M和V!function()&#123; var view = document.querySelector('#topNavBar') var controller = function(view)&#123; window.addEventListener('scroll', function(x) &#123; // ... &#125;) &#125; controller.call(undefined, view)&#125; 1234567891011121314151617181920212223242526// 将 controller 变成对象!function()&#123; var view = document.querySelector('#topNavBar') var controller = &#123; view: null, init: function(view) &#123; this.view = view this.bindEvents() // this.bindEvents.call(this) &#125;, bindEvents: function() &#123; var view = this.view window.addEventListener('scroll', function(e) &#123; if (window.scrollY &gt; 0) &#123; view.classList.add('sticky') &#125; else &#123; view.classList.remove('sticky') &#125; &#125;) &#125; &#125; controller.init(view) // controller.init.call(controller, view)&#125;.call() 123456789101112131415161718192021222324252627282930313233343536// 将对 view 的操作全部放在 controller 的属性内，使代码的结构变得清晰!function()&#123; var view = document.querySelector('#topNavBar') var controller = &#123; view: null, init: function(view) &#123; this.view = view this.bindEvents() // this.bindEvents.call(this) &#125;, bindEvents: function() &#123; var view = this.view window.addEventListener('scroll', (e) =&gt; &#123; // 1. 函数内 this 为触发事件的元素，使用 function()&#123;&#125; 需要绑定 this // function()&#123;&#125;.bind(this) // 2. 使用箭头函数。箭头函数没有 this，没有箭头函数的内外 this 是一样的 if (window.scrollY &gt; 0) &#123; this.active() &#125; else &#123; this.deactive() &#125; &#125;) &#125;， active: function() &#123; this.view.classList.add('sticky') &#125;, deactive: function() &#123; this.view.classList.remove('sticky') &#125; &#125; controller.init(view) // controller.init.call(controller, view)&#125;.call() MVCMVC 是一种组织代码的思想，使代码结构更清晰，方便后续的修改的扩展。 MVC 将代码分成三块： 控制器（Controller）- 负责转发请求，对请求进行处理（负责其他的所有事情）。 视图（View） - 界面设计人员进行图形界面设计（你的代码长什么样子或者你的代码在哪一块）。 模型（Model） - 程序员编写程序应有的功能（实现算法等等）、数据库专家进行数据管理和数据库设计(可以实现具体的功能)（一个操作数据的对象。初始化、获取和保存等）。 Model 和服务器交互，Model 将得到的数据交给 Controller，Controller 把数据填入 View，并监听 View用户操作 View，如点击按钮，Controller 就会接受到点击事件，Controller 这时会去调用 Model，Model 会与服务器交互，得到数据后返回给 Controller，Controller 得到数据就去更新 View。 MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller); 模型：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作. 视图：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。 控制器：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作;比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理; 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。 前端 MVC 是什么？ 答：MVC模式是软件工程中一种软件架构模式，一般把软件模式分为三部分，模型(Model)+视图(View)+控制器(Controller) 模型：模型用于封装与应用程序的业务逻辑相关的数据以及对数据处理的方法。模型有对数据直接访问的权利。模型不依赖 “视图” 和 “控制器”, 也就是说 模型它不关心页面如何显示及如何被操作. 视图：视图层最主要的是监听模型层上的数据改变，并且实时的更新html页面。当然也包括一些事件的注册或者ajax请求操作(发布事件),都是放在视图层来完成。 控制器：控制器接收用户的操作，最主要是订阅视图层的事件，然后调用模型或视图去完成用户的操作比如：当页面上触发一个事件，控制器不输出任何东西及对页面做任何处理 它只是接收请求并决定调用模型中的那个方法去处理请求, 然后再确定调用那个视图中的方法来显示返回的数据。 请用代码大概说明 MVC 三个对象分别有哪些重要属性和方法。 123456/*View('.xxx')*/window.View = function (selector) &#123; return document.querySelector(selector)&#125; 12345678910111213/*Model(&#123; 'resourceName': xxx&#125;)*/window.Model = function(object) &#123; let resourceName = object.resourceName return &#123; init: function() &#123;&#125;, fetch: function() &#123;&#125;, save: function(object) &#123;&#125; &#125;&#125; 1234567891011121314151617181920212223242526272829303132/*Controller(&#123; init: function(view, model) &#123; this.view = xxx this.model = xxx this.xxx() this.yyy() &#125;, xxx: function() &#123;&#125;, yyy: function() &#123;&#125;&#125;)*/window.Controller = function(options) &#123; let init = options.init let object = &#123; view: null, model: null, init: function(view, model) &#123; this.view = view this.model = model this.model.init() init.call(this, view, model) // this.bindEvents.call(this) &#125; &#125; for (let key in options) &#123; if (key !== 'init') &#123; object[key] = options[key] &#125; &#125; return object&#125;]]></content>
      <tags>
        <tag>MVC</tag>
        <tag>Promise</tag>
        <tag>解构赋值</tag>
        <tag>使用立即执行函数</tag>
        <tag>使用闭包</tag>
        <tag>封装 jQuery.ajax</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[从输入URL到页面加载发生了什么]]></title>
    <url>%2F2019%2F03%2F15%2F%E4%BB%8E%E8%BE%93%E5%85%A5URL%E5%88%B0%E9%A1%B5%E9%9D%A2%E5%8A%A0%E8%BD%BD%E5%8F%91%E7%94%9F%E4%BA%86%E4%BB%80%E4%B9%88%2F</url>
    <content type="text"><![CDATA[浏览器查找域名对应的 IP 地址概念解释 IP 地址：IP 协议为互联网上的每一个网络和每一台主机分配的一个逻辑地址。IP 地址如同门牌号码，通过 IP 地址才能确定一台主机位置。服务器本质也是一台主机，想要访问某个服务器，必须先知道它的 IP 地址； 域名（ DN ）：IP 地址由四个数字组成，中间用点号连接，在使用过程中难记忆且易输入错误，所以用我们熟悉的字母和数字组合来代替纯数字的 IP 地址，比如我们只会记住 www.baidu.com（百度域名） 而不是 220.181.112.244（百度的其中一个 IP 地址）； DNS（域名服务器）：每个域名都对应一个或多个提供相同服务服务器的 IP 地址，只有知道服务器 IP 地址才能建立连接，所以需要通过 DNS 把域名解析成一个 IP 地址。 查找过程以查询 www.baidu.com 的 IP 地址为例，其中2、3、4步均在上一步未查询成功的情况下进行 浏览器搜索自己的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统中的 DNS 缓存（维护一张域名与 IP 地址的对应表）； 搜索操作系统的 hosts 文件（ Windows 环境下，维护一张域名与 IP 地址的对应表）； 操作系统将域名发送至 LDNS（本地区域名服务器，如果你在学校接入互联网，则 LDNS 服务器就在学校，如果通过电信接入互联网，则 LDNS 服务器就在你当地的电信那里。）LDNS 查询自己的 DNS 缓存（一般查找成功率在 80% 左右），查找成功则返回结果，失败则发起一个迭代 DNS 解析请求； LDNS 向 Root Name Server （根域名服务器，其虽然没有每个域名的的具体信息，但存储了负责每个域，如 com、net、org等的解析的顶级域名服务器的地址）发起请求，此处，Root Name Server 返回 com 域的顶级域名服务器的地址； LDNS 向 com 域的顶级域名服务器发起请求，返回 baidu.com 域名服务器地址； LDNS 向 baidu.com 域名服务器发起请求，得到 www.baidu.com 的 IP 地址； LDNS 将得到的 IP 地址返回给操作系统，同时自己也将 IP 地址缓存起来； 操作系统将 IP 地址返回给浏览器，同时自己也将 IP 地址缓存起来； 至此，浏览器已经得到了域名对应的 IP 地址。 补充：域名与 URL 是两个概念。IP 地址与域名不是一一对应的关系。 建立连接–三次握手历程 主机向服务器发送一个建立连接的请求（您好，我想认识您）； 服务器接到请求后发送同意连接的信号（好的，很高兴认识您）； 主机接到同意连接的信号后，再次向服务器发送了确认信号（我也很高兴认识您），自此，主机与服务器两者建立了连接。 补充： TCP 协议：三次握手的过程采用 TCP 协议，其可以保证信息传输的可靠性，三次握手过程中，若一方收不到确认信号，协议会要求重新发送信号。 为什么要握手三次：确保 server 和 client 双方都能 发送请求 和 接收请求。 网页请求与显示当服务器与主机建立了连接之后，下面主机便与服务器进行通信。网页请求是一个单向请求的过程，即是一个主机向服务器请求数据，服务器返回相应的数据的过程。 浏览器根据 URL 内容生成 HTTP 请求，请求中包含请求文件的位置、请求文件的方式等等； 服务器接到请求后，会根据 HTTP 请求中的内容来决定如何获取相应的 HTML 文件； 服务器将得到的 HTML 文件发送给浏览器； 在浏览器还没有完全接收 HTML 文件时便开始渲染、显示网页； 在执行 HTML 中代码时，根据需要，浏览器会继续请求图片、CSS、JavsScript等文件，过程同请求 HTML ； 补充： TCP 数据包的数据有大小限制（1400字节），一次性发送大量数据则分成多个包。TCP 协议为每个包编号（sequence number，SEQ）。第一个包的编号是随机数，下一个数据包的编号是 1号包编号+1号包字节数。 断开连接–四次挥手 主机向服务器发送一个断开连接的请求（不早了，我该走了）； 服务器接到请求后发送确认收到请求的信号（知道了）； 服务器向主机发送断开通知（我也该走了）； 主机接到断开通知后断开连接并反馈一个确认信号（嗯，好的），服务器收到确认信号后断开连接； 补充： 为什么服务器在接到断开请求时不立即同意断开：当服务器收到断开连接的请求时，可能仍然有数据未发送完毕，所以服务器先发送确认信号，等所有数据发送完毕后再同意断开。 第四次握手后，主机发送确认信号后并没有立即断开连接，而是等待了 2 个报文传送周期，原因是：如果第四次握手的确认信息丢失，服务器将会重新发送第三次握手的断开连接的信号，而服务器发觉丢包与重新发送的断开连接到达主机的时间正好为 2 个报文传输周期。 资料 页面性能管理——阮一峰（页面生成过程、性能优化等） Chrome Devtool Performance 使用指南（译文）（原timeline） TLS/SSL握手过程——阮一峰 关于该问题的两篇博客： 从输入URL到页面加载发生了什么 1（这篇条理清晰，对于渲染略过了，可以结合第二篇、资料1） 从输入URL到页面加载发生了什么 2（比上者更优之处：DNS 解析图、HTTP 请求）单词错误：repain =&gt; repaint 关于 TCP 两篇都没怎么说，详见 资料6 浏览 HTTP 状态码（地铁地图） TCP 协议简介——阮一峰]]></content>
      <tags>
        <tag>DNS 缓存</tag>
        <tag>TCP</tag>
        <tag>页面渲染</tag>
        <tag>chrome performance</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[发送请求]]></title>
    <url>%2F2019%2F03%2F13%2F%E8%AF%B7%E6%B1%82%2F</url>
    <content type="text"><![CDATA[资料：浏览器同源政策及其规避方法 JSONP JSONP（JSON with Padding） 和 JSON 实际上没什么关系，传输的数据也可以为 string。 jQuery 将 JSONP 方法放在 $.ajax 下，实际上 JSONP 和 Ajax 也没啥关系。 为什么要用 JSONP ？ 用 form 表单提交会刷新页面 用 image 发起 GET 请求，不刷新页面，但是只能知道成功和失败，不能传输更多数据。 用 scirpt，后端无法知道前端要执行什么代码，耦合。 JSONP = script + callback。用 script + callback 的形式，发送 GET 请求来实现服务器与客户端跨源通信。动态创建 &lt;script&gt; 标签，用 callback 来传递参数降低前后端代码的耦合。 JSONP 为什么不支持 POST 请求答：因为 JSONP 是通过动态创建 &lt;script&gt; 标签实现的，动态创建 scirpt 时只能用 GET，没办法 POST。 AJAX请使用原生JS来发送AJAX请求JSON VS JS 关系：JSON 是一门抄袭了 JavaScript 的语言，同时也是一种数据交互格式，JSON 是 JavaScript 的子集（或者说 JSON 只抄袭了一部分 JavaScript 语法，而且没有新增任何原创的语法）。 区别：JSON 的字符串首尾必须是 &quot;， 有 Object / Array / Number / String / Null / Boolean，没有 Funciton 和 Undefined，没有内置的 Date、Math、RegExp 等。 JavaScript JSON undefined 没有 null null [‘a’, ‘b’] [“a”, “b”] function fn(){} 没有 {name: ‘celeste’} {“name”: “frank”} var a = {}a.self = a 搞不定（没有变量） {__proto__} 没有原型链 12345678910111213141516171819202122myButton.addEventListener('click', (e) =&gt; &#123; let request = new XMLHttpRequest() request.open('GET', '/xxx') // 配置 request request.send() request.onreadystatechange = () =&gt; &#123; if (request.readystate === 4) &#123; console.log('请求都响应完毕了') if (request.status &gt;= 200 &amp;&amp; request.status &lt; 300) &#123; console.log('说明请求成功') let string = request.responseText // 把符合 JSON 语法的字符串 // 转换成 JS 对应的值 let object = JSON.parse(string) // JSON.parse 是浏览器提供的 &#125; else if (request.status &gt;= 400) &#123; console.log('说明请求失败') &#125; &#125; &#125;&#125;) 同源策略用表单发送 GET 请求，可以跨域。因为获取到响应后页面会刷新，浏览器认为这样是安全的。用 AJAX 不能跨域。因为 AJAX 可以获取到响应内容， 浏览器必须保证只有 协议+端口+域名 一模一样才允许发 AJAX 请求 CORS(Cross-Origin Resource Sharing)后台加一个响应头，最好每个接口分开处理，不要写成全局的。response.setHeader(&#39;Access-Control-Allow-Origin&#39;, &#39;http://xxx.com:8000&#39;) 123GET /xxx HTTP/1.1HOST: jack.com:8002Content-type: application/x-www-form-url encoded JS 可以设置任意请求 header 吗XMLHttpRequest.setRequestHeader(header, value)是设置HTTP请求头的方法。必须在 open() 和 send() 之间调用。多次对同一请求头赋值，只会生成一个合并了多个值的请求头。 第一部分 request.open(‘get’, ‘/xxx’)第二部分 request.setHeader(‘Content-type’, ‘x-www-form-urlencoded’)第四部分 request.send(‘a=1&amp;b=2’) JS 设置请求体myReq.send() 12345// xhr.send(&apos;string&apos;);// xhr.send(new Blob());// xhr.send(new Int8Array());// xhr.send(&#123; form: &apos;data&apos; &#125;);// xhr.send(document); 第一部分 request.status / request.statusText第二部分 request.getResponseHeader() / request.getAllResponseHeaders()第四部分 request.responseText]]></content>
      <tags>
        <tag>JSONP</tag>
        <tag>AJAX</tag>
        <tag>同源策略</tag>
        <tag>CORS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[jQuery体验]]></title>
    <url>%2F2019%2F03%2F09%2FjQuery%E4%BD%93%E9%AA%8C%2F</url>
    <content type="text"><![CDATA[题目123456window.jQuery = ???window.$ = jQueryvar $div = $('div')$div.addClass('red') // 可将所有 div 的 class 添加一个 red$div.setText('hi') // 可将所有 div 的 textContent 变为 hi 思路第一次、第二次 传入的是字符串，直接用 DOM api 获取节点。 addClass：遍历 nodes，获取每个节点的 className，如果没有要添加的类，则添加。 setText：遍历 nodes，直接在每个节点写入 textContent。 一开始使用 for 循环遍历，querySelectorAll 获取到的为类数组对象，改成了 forEach 遍历，addClass、setText 函数内将 nodes 换成 this，感觉这样可以实现更松散的耦合。 1234567891011121314window.jQuery = function (nodeOrSelector) &#123; let nodes = document.querySelectorAll(nodeOrSelector) nodes.addClass = function (classes) &#123; this.forEach(t =&gt; &#123; if (!t.className.split(' ').includes(classes)) &#123; t.classList.add(classes) &#125; &#125;) &#125; nodes.setText = function (text) &#123; this.forEach(t =&gt; t.textContent = text) &#125; return nodes&#125; 第三次 上述功能没有达到参数 nodeOrSelector 代表的含义，传入节点是不行的。 增加对 nodeOrSelector 的判断，分 string 和 node 第四次 改完发现传入多个节点时是错误的，一个节点的部分原型链是这样的，HTMLDivElement -&gt; HTMLElement -&gt; Element -&gt; Node，多个节点的原型对象是 HTMLCollection 的实例，判断改成 string、Node 的实例或 HTMLCollection 的实例。 let nodes = {} -&gt; let nodes = { length: 0 } 觉得既然是伪数组，那么一开始就要有 length 属性。 让节点的原型链纯净，只将需要的属性值赋给 nodes。 123456789101112131415161718192021222324window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123; length: 0 &#125; // 传入字符串 if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) nodes.length = temp.length for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; &#125; // 传入1个节点 else if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; // 传入多个节点 else if (nodeOrSelector instanceof HTMLCollection) &#123; let temp = nodeOrSelector nodes.length = temp.length for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; &#125; ...&#125; 第五次 遍历代码重复了，累赘，封装成函数 123456789101112131415161718192021222324252627282930313233343536373839window.jQuery = function (nodeOrSelector) &#123; let nodes = &#123; length: 0 &#125; // 传入1个节点 if (nodeOrSelector instanceof Node) &#123; nodes = &#123; 0: nodeOrSelector, length: 1 &#125; &#125; else &#123; function cloneObject(nodes, temp) &#123; nodes.length = temp.length for (let i = 0; i &lt; temp.length; i++) &#123; nodes[i] = temp[i] &#125; &#125; // 传入字符串 if (typeof nodeOrSelector === 'string') &#123; let temp = document.querySelectorAll(nodeOrSelector) cloneObject(nodes, temp) &#125; // 传入多个节点 else if (nodeOrSelector instanceof HTMLCollection) &#123; let temp = nodeOrSelector cloneObject(nodes, temp) &#125; &#125; nodes.addClass = function (classes) &#123; for (let i = 0; i &lt; this.length; i++) &#123; if (!this[i].className.split(' ').includes(classes)) &#123; this[i].classList.add(classes) &#125; &#125; &#125; nodes.setText = function (text) &#123; for (let i = 0; i &lt; this.length; i++) &#123; this[i].textContent = text &#125; &#125; return nodes&#125; done.]]></content>
      <tags>
        <tag>jQuery</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[函数笔记]]></title>
    <url>%2F2019%2F03%2F08%2F%E5%87%BD%E6%95%B0%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[函数就是一段可以反复调用的代码块。 console.log(xxx) 只接受字符串，xxx 不是字符串就调用 toString()。 函数默认 return undefined。声明变量时也是如此。 函数的 name 属性为 关键字后的 标识符，匿名函数为变量名，奇葩：fn = new Funcition(...)，fn.name === “anonymous” 函数的 5 种声明 具名函数 1234function f(x,y)&#123; return x+y&#125;f.name // 'f' 匿名函数 12345var ff = function(x,y)&#123; return x+y&#125;f.name // 'f' 具名函数赋值 1234var ff = function f2(x,y)&#123; return x+y &#125;f.name // 'f2'console.log(f2) // undefined window.Function 12var f = new Function('x','y','return x+y')f.name // "anonymous" 箭头函数 12345var f = (x,y) =&gt; &#123; return x+y&#125;var sum = (x,y) =&gt; x+yvar n2 = n =&gt; n*n 花括号和 return 可以一起去掉，不能只省略一个；箭头函数没有 arguments。 如何调用函数f.call(asThis, input1,input2)其中 asThis 会被当做 this，[input1,input2] 会被当做 arguments禁止使用 f(input1, input2)，因为学会 .call 才能理解 this this 和 arguments1234567function f()&#123; 'use strict' console.log(this) console.log(arguments) return undefined&#125;f.call(1,2,3) // this 为 1，arguments 为 [2,3] 什么是 call stack作用域 按照语法树，就近原则 我们只能确定变量是哪个变量，但是不能确定变量的值 e.g., 在函数内写 a = 1， 并不是在声明全局变量，只是（1）赋值，（2）按照语法树查找不到声明，才会声明并赋值。 面试题1 123456var a = 1function f1()&#123; alert(a) // 是多少 var a = 2&#125;f1.call() 拿到代码直接做——必然会错。请先提升声明 面试题2 123456789var a = 1function f1()&#123; var a = 2 f2.call()&#125;function f2()&#123; console.log(a) // 是多少&#125;f1.call() 拿到代码直接做——必然会错。请先提升声明 面试题3 123456var liTags = document.querySelectorAll('li')for(var i = 0; i&lt;liTags.length; i++)&#123; liTags[i].onclick = function()&#123; console.log(i) // 点击第3个 li 时，打印 2 还是打印 6？ &#125;&#125; 拿到代码直接做——必然会错。请先提升声明 闭包 如果一个函数，使用了它范围外的变量，那么（这个函数 + 这个变量）就叫做闭包 函数的本质 Function对象覆盖了从Object继承来的 toString 方法。对于用户定义的 Function 对象，toString方法返回一个字符串，其中包含用于定义函数的源文本段。 其他立即执行，不声明全局变量 123456789101112131415(function() &#123; var parent = document.body console.log(parent)&#125;).call()(function() &#123; var parent = document.body console.log(parent)&#125;.call())// + - ! ~ 让浏览器知道后面不是声明-function() &#123; var parent = document.body console.log(parent)&#125;.call() 代码块：1234&#123; let parent = document.body // let 的作用域逃不出花括号&#125;console.log(parent) // window 12&#123; var parent = document.body &#125;console.log(parent) // window 上述代码相当于12var parent // 变量提升&#123; parent = document.body &#125;]]></content>
      <tags>
        <tag>函数</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Array笔记]]></title>
    <url>%2F2019%2F03%2F07%2FArray%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[基本类型构造函数加 new ，才是对象 12Number() // 基本类型new Number() // 对象 创建函数 1var f = new Function(&apos;a&apos;, &apos;b&apos;, &apos;return a+b&apos;) 数组也可像对象一样赋值（数组是你觉得它是数组）但是 length 依旧为3不同遍历方法 伪数组：实例的 [[Prototype]] 内置属性（浏览器中表现为 __proto__）中，没有 Array.prototype。 e.g, arguments. 12345678function xxx() &#123; console.log(&apos;hi&apos;) &#125;// 执行xxx() xxx.call()// 放到内存中，不执行xxx arr.forEach(function (currentValue, index, array) {}, thisArg);通过 this 获取 array arr.sort(function (a, b) { return a - b }) a - b 从小到大；b - a 从大到小。 只有 sort 会改变原值 arr + ‘’ === arr.join() // 实际上调用了 toString() 方法 arr.map() 有返回值，map: 映射。 arr.filter() 返回布尔值，只留下符合条件的 filter 和 map 一起用，对过滤的值操作。arr.filter((item, index) =&gt; item === index).map(t =&gt; t + 1) arr.reduce()，reduce(减少，归纳为 =&gt; 求和)a.reduce((prevSum, n) =&gt; prevSum + n, 0) prevSum 上一次运算的结果，n 当前值 范围打劫]]></content>
      <tags>
        <tag>array</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript 教程 - DOM api 归档]]></title>
    <url>%2F2019%2F03%2F06%2FDOM%2F</url>
    <content type="text"><![CDATA[知道有这么个功能就行，详情见 Google or JavaScript 教程 / DOM 概述DOMDOM 是 JavaScript 操作网页的接口，全称为“文档对象模型”（Document Object Model）。 节点DOM 的最小组成单位叫做节点（node）。 节点的类型有七种。 Document：整个文档树的顶层节点 DocumentType：doctype标签（比如&lt;!DOCTYPE html&gt;） Element：网页的各种HTML标签（比如&lt;body&gt;、&lt;a&gt;等） Attribute：网页元素的属性（比如class=”right”） Text：标签之间或标签包含的文本 Comment：注释 DocumentFragment：文档的片段 浏览器提供一个原生的节点对象Node，七种节点都继承了Node，因此具有一些共同的属性和方法。 节点树DOM 树：节点按所在层级，抽象成树状结构。根节点：&lt;html&gt;。除根节点，其他节点有三种层关系。 父节点关系（parentNode）：直接的那个上级节点 子节点关系（childNodes）：直接的下级节点 同级节点关系（sibling）：拥有同一个父节点的节点 Node 接口 均为 Node.prototype.xxx，不重复写了。 属性 nodeType：整数，节点类型。(文档-9，元素-1，属性-2，文本-3，文档片断-11，文档类型-10，注释-8），有对应常量(e.g.,Node.DOCUMENT_NODE)。 nodeName：节点名，元素大写（e.g.,DIV），#xxx 等。 nodeValue：返回字符串，节点文本值，可读写，text、comment、attr 有值，别的 null。div要读儿子的文本。 textContent：返回自己和子孙的文本，忽略 HTML 标签。写入时对 HTML 标签转义。有节点该属性为 null。和innerText（IE）有差异，innerText 不包括 style 标签、script 标签，不展示隐藏文本。 baseURI：字符串，网页绝对路径。只读。&lt;base&gt; &gt; window.location。 ownerDocument：找出我的祖宗。顶层文档对象，即document对象。document.ownerDocument === null。 nextSibling：我后面的兄弟。包括文本节点和注释节点。空格也是兄弟。可用来遍历。 previousSibling：我前面的兄弟。之后同上。 parentNode：找爸爸。有人没爸爸 null。生出来没上户口的 null。node.parentNode.removeChild(node);自己不想活了。 parentElement：只要是 element 的爸爸，document 和 documentfragment 滚蛋。 firstChild，lastChild：第一个儿子（element or text or comment），没有就 null。 childNodes：类数组对象，把我的儿子们（text 和 comment 弱鸡也是我的儿子）打包。没儿子给个空包。动态集合。 isConnected：布尔值，看看我上户口了没。 方法 appendChild()：喜当爹，送你个娃。返回值是这个娃。例外：娃 是 DocumentFragment 时，自己查。 hasChildNodes()：布尔值，我有没有娃（还有2种方法）。 cloneNode(deep)：造一个同卵双胞胎。有唯一属性要改、监听\事件\回调 不能克隆。cloneNode(true) 深拷贝 insertBefore()：插入父节点内指定元素前。 removeChild()：把这个儿子赶出家门。(把不是儿子的人赶出家门会报错)。只是从页面上消失，还是存在于内存中的。 replaceChild()：辣鸡，我要换个人做儿子。 contains()：布尔值，看看我和子孙们上族谱了没。 compareDocumentPosition()：返回一个六个比特位的二进制值，表示参数节点与当前节点的关系。两人可能关系复杂，返回数值为总和，需与掩码 与运算，具体判断。 isEqualNode()，isSameNode()：布尔值，是否相等。类型相同、属性相同、子节点相同。equal 看起来相同，same 真的是同一个节点。 isEqualNode()，isSameNode()：布尔值，是否相等。类型相同、属性相同、子节点相同。equal 看起来相同，same 真的是同一个节点。 normalize()：去除空文本节点，毗邻的文本节点合并。Text.splitText的逆方法。 getRootNode()：作用等于 ownerDocument，but，document.getRootNode() // document。 NodeList 接口，HTMLCollection 接口 节点集合：NodeList(contain the various types node) 和 HTMLCollection（HTML element node only）。 NodeList 接口（NodeList.prototype.xxxxx） 概述： NodeList实例是类数组对象，成员为节点对象。 创建NodeList实例：（1）Node.childNodes；（2）document.querySelectorAll()等节点搜索方法。 转为真正的数组：var nodeArr = Array.prototype.slice.call(document.body.childNodes);。 Node.childNodes 动态集合，别的为静态集合。 length：返回节点数。 forEach()：用法同数组 forEach()。 item()：返回该位置成员。 keys()，values()，entries()：类似 Object.xxx。 HTMLCollection 接口（HTMLCollection.prototype.xxx） 概述： 只有元素节点，类数组对象，只能 for 循环遍历。 HTMLCollection 实例都为动态集合。 length：成员数量。 item()：返回该位置成员。 namedItem()：返回 id 或 name 为指定字符串的元素节点，没有就 null。 mdwoyaokantule ParentNode 接口，ChildNode 接口 ParentNode 接口（ParentNode.xxx） children：all child element nodes. firstElementChild： nothing special. lastElementChild：nothing special.. childElementCount：nothing special… append()，prepend()：添加 元素 or 文字子节点。往后加 / 往前加。 ChildNode 接口（有爸爸就能用） ChildNode.remove()：让自己从世界消失。 ChildNode.before()，ChildNode.after()：insert sibling before or after myself. ChildNode.replaceWith()：替换节点。 Document 节点 概述：document 节点 -&gt; 整个文档。document 对象有不同办法获取，详情见Google。 属性（document.xxx） 快捷方式属性： defaultView：返回 document 对象所属的 window 对象，无则 null。 doctype：指向&lt;DOCTYPE&gt;节点。 documentElement：返回当前文档的 根元素节点，一般为 &lt;html&gt; 节点。 body，head：指向相应节点，代码里不写，浏览器给你加。可写。 scrollingElement：当前文档的滚动元素。 activeElement：获得焦点的 DOM 元素。e.g.,&lt;input&gt;、&lt;textarea&gt;、&lt;select&gt;等表单元素。无返回 &lt;body&gt; 或 null。 fullscreenElement：全屏展示的 DOM 元素。比如查看 &lt;video&gt; 元素是否为全屏状态。 节点集合属性： links：所有设定了 href 属性的 &lt;a&gt; 及 &lt;area&gt; 节点。 forms：所有 &lt;form&gt; 节点。可用 id 和 name 来引用。 images：所有图片节点。可以用 imgList[i].src === ‘xxx’ 来查找某张图。 embeds，plugins：所有 &lt;embed&gt; 节点。 scripts：所有。。。 styleSheets：文档内嵌或引入的样式表集合。 小结：除了document.styleSheets，别的都返回 HTMLCollection 实例。 我挂了，这篇博客先太监吧，IDE 你要学会自己写代码呀 - 文档静态信息属性： - 文档状态属性： - cookie： - designMode： - implementation： 方法（document.xxx） open()，close()：open -&gt; write -&gt; close,异步操作时，使用 document.write 容易把页面冲掉 write()，writeln()： querySelector()，querySelectorAll()： getElementsByTagName()： getElementsByClassName()： getElementsByName()： getElementById()： elementFromPoint()，elementsFromPoint()： caretPositionFromPoint()： createElement()： createTextNode()： createAttribute()： createComment()： createDocumentFragment()： createEvent()： addEventListener()，removeEventListener()，dispatchEvent()： hasFocus()： adoptNode()，importNode()： createNodeIterator()： createTreeWalker()： execCommand()，queryCommandSupported()，queryCommandEnabled()： getSelection()： Element 节点 实例属性元素特性的相关属性元素状态的相关属性Element.attributesElement.className，Element.classListElement.datasetElement.innerHTMLElement.outerHTMLElement.clientHeight，Element.clientWidthElement.clientLeft，Element.clientTopElement.scrollHeight，Element.scrollWidthElement.scrollLeft，Element.scrollTopElement.offsetParentElement.offsetHeight，Element.offsetWidthElement.offsetLeft，Element.offsetTopElement.styleElement.children，Element.childElementCountElement.firstElementChild，Element.lastElementChildElement.nextElementSibling，Element.previousElementSibling 实例方法属性相关方法Element.querySelector()Element.querySelectorAll()Element.getElementsByClassName()Element.getElementsByTagName()Element.closest()Element.matches()事件相关方法Element.scrollIntoView()Element.getBoundingClientRect()Element.getClientRects()Element.insertAdjacentElement()Element.insertAdjacentHTML()，Element.insertAdjacentText()Element.remove()Element.focus()，Element.blur()Element.click() 参考链接 属性的操作 Element.attributes 属性 元素的标准属性 属性操作的标准方法概述Element.getAttribute()Element.getAttributeNames()Element.setAttribute()Element.hasAttribute()Element.hasAttributes()Element.removeAttribute() dataset 属性 Text 节点和 DocumentFragment 节点 Text 节点的概念 Text 节点的属性 data wholeText length nextElementSibling，previousElementSibling Text 节点的方法 appendData()，deleteData()，insertData()，replaceData()，subStringData() remove() splitText() DocumentFragment 节点 CSS 操作 HTML 元素的 style 属性 CSSStyleDeclaration 接口 简介 CSSStyleDeclaration 实例属性 CSSStyleDeclaration 实例方法 CSS 模块的侦测 CSS 对象 CSS.escape() CSS.supports() window.getComputedStyle() CSS 伪元素 StyleSheet 接口 概述 实例属性 实例方法 实例：添加样式表 CSSRuleList 接口 CSSRule 接口 概述 CSSRule 实例的属性 CSSStyleRule 接口 CSSMediaRule 接口 window.matchMedia() 基本用法 MediaQueryList 接口的实例属性 MediaQueryList 接口的实例方法 Mutation Observer API 概述 MutationObserver 构造函数 MutationObserver 的实例方法 observe() disconnect()，takeRecords（） MutationRecord 对象 应用示例 子元素的变动 属性的变动 取代 DOMContentLoaded 事件 参考链接]]></content>
      <tags>
        <tag>心痛</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[原型与原型链]]></title>
    <url>%2F2019%2F03%2F05%2F%E5%8E%9F%E5%9E%8B%E4%B8%8E%E5%8E%9F%E5%9E%8B%E9%93%BE%2F</url>
    <content type="text"><![CDATA[单体内置对象ECMA-262 内置对象的定义：”由ECMAScript实现提供的、不依赖于宿主环境的对象，这些对象在ECMAScript程序执行之前就存在了”ECMA-262还定义了2个单体内置对象：Global 和 Math。 Global对象事实上，没有全局变量或全局函数；所有在全局作用域中定义的属性和函数，都是Global对象的属性。Global对象还包含其他一些方法。 URI编码方法encodeURI() : 将空格替换成 %20encodeURIComponent()：使用对应的编码替换所有非字母数字字符。对整个 URI 使用 encodeURI()，对添加在现有 URI 的字符串使用 encodeURIComponent()。解码decodeURI() 、decodeURIComponent() eval()方法只接收一个参数，即要执行的ECMAScript（或JavaScript）字符串。eval(“alert(‘hello’)”) 等价于 alert(“hello”)严格模式下，在外部访问不到创建在 eval() 中的任何变量和函数；为eval赋值也会导致错误。 Global对象的属性特殊值：NaN、Infinity、undefined；构造函数：Object, Array, Function, Boolean, String, Number, Date, RegExp, Error, EvalError, RangeError, ReferenceError, SyntaxError, TypeError, URIError window对象ECMAScript没有直接说如何访问Global对象，不过Web浏览器都是将Global对象作为window对象的一部分加以实现的。取得Global对象的另一种方法（在任何执行环境下都可行）：123var global = function() &#123; return this;&#125; (); Math对象Math对象：ECMAScript为保存数学公式和信息提供的公共位置。Math对象提供的计算功能，比我们用JS编写的算法执行更快。 Math对象的属性数学计算中可能用到的特殊值。例：Math.E，即常量e的值。 min() 和 max()方法（1）可接受任意多个参数值，返回最大、最小值。var max = Math.max(3, 45, 34, 32);alert(max); // 45（2）用来查询数组对象中的最大、最小值（结合apply()方法）var values = [1, 3, 4, 5, 6];var max = Math.max.apply(Math, values); // 关键是把 Math 对象作为 apply()的第一个参数，从而正确地设置 this 值 舍入方法小数舍入为整数Math.ceil(23.7)：向上 // 24Math.floor(23.4)：向下 // 23Math.round(78.5454)：四舍五入 // 79 random()方法Math.random() 返回一个 大于等于0 小于1的随机数值 = Math.floor(Math.random() * 可能值的总数 + 第一个可能的值) 其他方法弦切角，绝对值，自然对数，平方根，幂等。 创建对象对创建对象方法的理解&gt;&gt; 对原型的理解 函数有 prototype 属性，prototype 属性为一个指针，指向原型对象。 原型对象默认有 constructor 属性，指向 prototype 属性所在的函数。 自定义的构造函数，其原型对象默认只取得 constructor 属性，别的从 Object 继承。 构造函数创建实例后，实例有内部属性 [[Prototype]]，指向构造函数的原型对象，脚本中没有标准的方式访问。但在 Firefox、Safari 和 Chrome 中，每个对象有属性 proto；其他实现中，该属性对脚本不可见。 判断实例的 [[Prototype]] 属性是否指向某个原型对象（即 实例person1 是否为 构造函数Person 的实例）：alert(Person.prototype.isPrototypeOf(person1)); //true 获取实例的 [[Prototype]] 属性的指向 Object.getPrototypeOf(实例)alert(Object.getPrototypeOf(person1) == Person.prototype); //truealert(Object.getPrototypeOf(person1).name); //&quot;Nicholas&quot; 读取实例的属性时，可以获取原型对象的同名属性的值的原因：和读取对象的属性值得过程有关。 读取某个对象某个属性的过程：从对象实例开始查找，如果有该名字的属性，返回该属性的值；若没有找到，则继续搜索指向的原型对象，如果有该名字的属性，则返回原型对象中同名属性的值。 原型对象中的属性不能通过实例修改，但是可以给实例定义同名属性来覆盖原型对象中属性的值。 hasOwnProperty() 方法：判断实例是否有给定名字的属性，返回布尔值。可以用来判断访问的是实例属性还是原型对象属性。alert(person1.hasOwnProperty(“name”)); //false Object.getOwnPropertyDescriptors() 方法：获取实例属性的描述符，若要获取原型属性的描述符则需要对原型对象使用该方法。 // 此处发现一个bug hhhh，书中（红宝书）方法错了，结尾少了字母 ‘s’。 继承许多OO语言都支持两种继承方式：接口继承和实现继承。 接口继承只继承方法签名，实现继承则继承实际的方法。 由于函数没有签名，ECMAScript中不能实现接口继承，ECMAScript 只支持实现继承，其实现继承的实现主要依靠原型链。 原型链 原型链的基本思想：利用原型让一个引用对象继承另一个引用对象的方法和属性。 实现原型链有一种基本模式，其代码大致如下。 123456789101112131415161718192021function SuperType() &#123; this.property = true;&#125;SuperType.prototype.getSuperValue = function() &#123; return this.property;&#125;;function SubType() &#123; this.subproperty = false;&#125;// 继承了 SuperTypeSubType.prototype = new SuperType();SubType.prototype.getSubValue = function() &#123; return this.subproperty;&#125;;var instance = new SubType();alert(instance.getSuperType()); // true SubType 继承了 SuperType，继承是通过创建 SuperType 的实例，并将该实例赋给 SubType.prototype 实现的。 实现的本质是重写原型对象，代之以一个新类型的实例。（原来存在于 SuperType 实例中的所有方法和属性，现在也存在于 SubType.prototype 中了） 需要注意的是，现在 instance.constructor 指向的是 SuperType，因为 SubType.prototype 被重写为 SuperType 的实例。 别忘记默认的原型所有引用类型默认都继承了 Object，所有函数的默认原型都是 Object 的实例。因此默认原型都是包含一个内部指针，指向 Object.prototype，这也正是所有自定义类型都会继承一些默认方法的根本原因。 确定原型和实例的关系[1] instanceof 操作符：测试实例和原型链中出现过的构造函数，都会返回 true。由于原型链的关系，我们可以说 instance 是 Object、SuperType 或 SubType 中任何一个类型 的实例。[2] isPrototypeOf() 方法：只要是原型链中出现过的原型，都可以说是该原型链所派生的实例的原型，因此都会返回 true。 alert(Object.prototype.isPrototypeOf(instance)); // true alert(SuperType.prototype.isPrototypeOf(instance)); // true alert(SubType.prototype.isPrototypeOf(instance)); // true 谨慎地定义方法给原型添加方法的代码一定要放在替换原型的语句之后。在通过原型链继承时，不可以用对象字面量创建原型方法，这样会重写原型链。 原型链的问题没有办法在不影响所有对象实例的情况下，给超类型的构造函数传递参数。 借用构造函数（伪造对象或经典继承）通过使用apply()和call()方法，在新创建的对象上执行构造函数，由此来解决原型中包含引用类型的问题。 (1) 传递参数1234567891011121314function SuperType(name)&#123; this.name = name;&#125;function SubType()&#123; //继承了 SuperType，同时还传递了参数 SuperType.call(this, "Nicholas");+ //实例属性 this.age = 29;&#125;var instance = new SubType();alert(instance.name); //"Nicholas";alert(instance.age); //29 (2) 借用构造函数的问题 方法都在构造函数中定义，无法实现函数复用。 组合继承（伪经典继承） 将原型链和借用构造函数的技术结合。思路：使用原型链实现对原型方法和属性的继承，而通过对构造函数实现对实例属性的继承。 intanceof 和 isPrototypeOf() 能够识别基于组合继承创建的对象。 原型式继承借助原型可以已有的对象创建新对象，同时还不必因此创建自定义类型。 1234567891011121314151617181920function object(o) &#123; function F() &#123;&#125; F.prototype = o; return new F();&#125; var person = &#123; name: "Nicholas", friends: ["Shelby", "Court", "Van"]&#125;;var anotherPerson = object(person);anotherPerson.name = "Greg";anotherPerson.friends.push("Rob");var yetAnotherPerson = object(person);yetAnotherPerson.name = "Linda";yetAnotherPerson.friends.push("Barbie");alert(person.friends); //"Shelby,Court,Van,Rob,Barbie" ECMAScript5新增的Object.create()，接收2个参数：要继承的对象和（可选）为对象添加额外属性的对象。 123456789101112var person = &#123; name: "peanut", friends: ["aaa", "bbb"]&#125;; var anotherPerson = Object.create(person, &#123; name: &#123; value: "Greg" &#125;&#125;);alert(anotherPerson.name); //"Greg" 寄生式继承 即创建一个仅用于封装继承过程的函数，该 函数在内部以某种方式来增强对象，最后再像真地是它做了所有工作一样返回对象。 无法函数复用。 寄生组合式继承 组合继承中会执行两次超类型的构造函数，导致子类型实例和子类型原型中存在相同的重复属性。 12345678910111213141516171819202122232425function inheritPrototype(subType, superType)&#123; var prototype = object(superType.prototype); //创建对象 prototype.constructor = subType; //增强对象 subType.prototype = prototype; //指定对象&#125;function SuperType(name)&#123; this.name = name; this.colors = ["red", "blue", "green"];&#125;SuperType.prototype.sayName = function()&#123; alert(this.name);&#125;;function SubType(name, age)&#123; SuperType.call(this, name); this.age = age;&#125;inheritPrototype(SubType, SuperType);SubType.prototype.sayAge = function()&#123; alert(this.age);&#125;; 使用寄生组合继承子类型将通过原型链继承超类型的属性和方法，而在子类型实例中将不再有重复的属性。 小结 继承：将超类型的实例赋值给子类型的 prototype 属性（此时子类型原型对象的 constructor 属性会指向超类型的构造函数），从而继承超类型的所有属性和方法。 实现继承的方法： 原型链 借用构造函数 组合继承 原型式继承 寄生式继承 寄生组合式继承]]></content>
      <tags>
        <tag>原型链</tag>
        <tag>单体内置对象</tag>
        <tag>Global对象</tag>
        <tag>Math对象</tag>
        <tag>原型</tag>
        <tag>继承</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[普通类型和对象的区别]]></title>
    <url>%2F2019%2F03%2F04%2F%E6%99%AE%E9%80%9A%E7%B1%BB%E5%9E%8B%E5%92%8C%E5%AF%B9%E8%B1%A1%E7%9A%84%E5%8C%BA%E5%88%AB%2F</url>
    <content type="text"><![CDATA[动态类型JavaScript 是一种弱类型或者说动态语言。这意味着你不用提前声明变量的类型，在程序运行过程中，类型会被自动确定。这也意味着你可以使用同一个变量保存不同类型的数据：123var foo = 42; // foo is a Number nowfoo = "bar"; // foo is a String nowfoo = true; // foo is a Boolean now 类型转换变 String xxx.toString()1.toString 报错；1..toString -&gt; &quot;1&quot; 第一个点被当成小数点，第二点用来接 api String(xxx) ‘’ + xxx （推荐） 变 Boolean !!xxx （推荐） Boolean(xxx) 类型 值 布尔值 备注 number 0 / NaN false 其余为 true string “” false 其余为 true null null false - undefined undefined false - object {}，包括 Array、Function true 全部为 true falay 值：0、NaN、null、undefined、空字符串（’’ or “”）、false 变 Number ‘1’ -&gt; 1 Number(&#39;1&#39;) === 1 parseInt(&#39;1&#39;, 10) === 1 parseFloat(&#39;1.23&#39;) === 1.23 &#39;1&#39; - 0 -&gt; 1 （推荐） + &#39;.0&#39; -&gt; 0.1; + &#39;-1&#39; -&gt; -1 (并非取绝对值) Object 、内存123// wrongvar a = &#123; self: a &#125;// a.self 为 undefined 等价于 12var a // 变量提升a = &#123; self: a &#125; 123// correctvar a = &#123;&#125;a.self = a 引用类型的比较是引用的比较123var person1 = &#123; 'name': 'pikachu' &#125;var person2 = &#123; 'name': 'pikachu' &#125;console.log(person1 === person2); // false 虽然变量 person1 和变量 person2 都是表示一个内容为 &#39;name&#39;: &#39;pikachu&#39; 的对象，但是其在内存中的位置不一样，也就是说变量 person1 和变量 person2 指向的不是同一个对象，所以它们是不相等的。 你买一个 8G 的内存条操作系统开机即占用 512MBChrome 打开即占用 1G 内存Chrome 各每个网页分配一定数量的内存这些内存要分给页面渲染器、网络模块、浏览器外壳和 JS 引擎（V8引擎）JS 引擎将内存分为代码区和数据区我们只研究数据区数据区分为 Stack（栈内存） 和 Heap（堆内存）简单类型的数据直接存在 Stack 里复杂类型的数据是把 Heap 地址存在 Stack 里 垃圾回收如果一个对象没有被引用，它就是垃圾，将被回收 JavaScript 是一门具有自动垃圾收集机制的编程语言，开发人员不必关心内存分配和回收问题。可以对 JavaScript 的垃圾收集例程作如下总结。 离开作用域的值将被自动标记为可以回收，因此将在垃圾收集期间被删除。 “标记清除“是目前主流的垃圾收集算法，这种算法的思想是给当前不使用的值加上标记，然后再回收其内存。 另一种垃圾收集算法是”引用计数“，这种算法的思想是跟踪记录所有值被引用的次数。JavaScript引擎目前都不再使用这种算法;但在 IE 中访问非原生 JavaScript 对象(如 DOM 元素)时，这种算法仍然可能会导致问题。 当代码中存在循环引用现象时，”引用计数”算法就会导致问题。 解除变量的引用不仅有助于消除循环引用现象，而且对垃圾收集也有好处。为了确保有效地回收内存，应该及时解除不再使用的全局对象、全局对象属性以及循环引用变量的引用。]]></content>
      <tags>
        <tag>类型转换</tag>
        <tag>垃圾回收</tag>
        <tag>内存图</tag>
        <tag>浅拷贝/深拷贝</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS_深入浅出_笔记]]></title>
    <url>%2F2019%2F03%2F04%2FCSS-%E6%B7%B1%E5%85%A5%E6%B5%85%E5%87%BA-%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[1. CSS 学习思路 监测是否支持 touch 事件：(1)’ontouchstart’ in documentbody(2)document.body.ontouchstart === undefined (不支持。 === null 支持) p标签 内，img float，文字则环绕 github markdown css border 和 margin，display: table.flex, 阻断 margin 的合并；overflow: hidden; li 小圆点，display: list-item; 的属性，换了 display，就没有小圆点 内联元素display: inline/inline-block，position: absolute; 后，-&gt; display: block; 一元素 position: fixed; 在 css 中插入内容，父级使用 transform: scale(); 此时，该元素变成相对于父级定位 ‘你好’没有在浮动元素下，相当于文字环绕浮动图片 CSS 3 generator cndevdocs.com 2. 宽度与高度 元素的高度是行高决定的(单行)。 默认行高是字体设计师确定的，在字体文件中有。在自定义很小的行高（比如 1px）时有可能会失效。 &amp;nbsp;：no break space. text-align: justify;： 多行文字两边对齐。 如何让单行文字两边对齐？ 换行：单词加上 - 才会换行。 一行文字超出省略号 12345.inlineText &#123; white-space: nowrap; overflow: hidden; text-overflow: ellipsis; &#125; 多行省略号 123456&#123; display: -webkit-box; -webkit-line-clamp: 2; -webkit-box-orient: vertical; overflow: hidden;&#125; div 的宽度不是文字决定的。 浏览器份额查询关键系：百度统计 浏览器。 margin 合并：父级的四周没有东西挡起来（e.g., border/padding/overflow: hidden;/在父级内加文字可以），父级和子级的 margin 会合并。测试时可以给父级加 outline: 1px solid red。 总结div 的高度是由什么决定的div 高度是由它内部文档流中的元素高度总和决定的，并不是相等。div 宽度默认自适应。 正方形： 123456&#123; border: 1px solid; /* 100% 表示和宽度一样 */ padding-top: 100%;&#125; span 的高度、宽度是由什么决定的高度：行高决定。宽度：内容 + 左右margin + 左右padding + 左右border宽度 文档流文档流就是内联元素从左到右，块级元素从上到下。 脱离文档流算高度的时候别算上我 方法 float position: absolute; position: fixed; 绝对居中使用场景：例如父级为全屏显示的元素时。 子元素要定宽定高12345678.son &#123; position: absolute; top: 0; right: 0; bottom: 0; left: 0; margin: auto;&#125; flexIE 不兼容 123456.dad &#123; display: flex; justify-content: center; align-items: center; /* height: 100vh; */&#125; 3. 堆叠上下文资料：深入理解CSS中的层叠上下文和层叠顺序 什么是堆叠顺序(The stacking order) background border 块级 浮动 内联 z-index: 0 z-index: + 如果是兄弟元素重叠，那么后面的盖在前面的身上。 堆叠上下文(The stacking context)https://developer.mozilla.org/zh-CN/docs/Web/Guide/CSS/Understanding_z_index/The_stacking_context 可以理解为堆叠作用域。跟 BFC 一样，我们只知道一些属性会触发堆叠上下文，但并不知道堆叠上下文是什么。 1.根元素 (HTML),1.z-index 值不为 “auto”的 绝对/相对定位，1.一个 z-index 值不为 “auto”的 flex 项目 (flex item)，即：父元素 display: flex|inline-flex，1.opacity 属性值小于 1 的元素（参考 the specification for opacity），1.transform 属性值不为 “none”的元素，1.mix-blend-mode 属性值不为 “normal”的元素，1.filter值不为“none”的元素，1.perspective值不为“none”的元素，1.isolation 属性被设置为 “isolate”的元素，1.position: fixed1.在 will-change 中指定了任意 CSS 属性，即便你没有直接指定这些属性的值（参考 这篇文章）1.-webkit-overflow-scrolling 属性被设置 “touch”的元素]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JS_数据类型]]></title>
    <url>%2F2019%2F03%2F04%2FJS-%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、 JS 的历史 1991年，李爵士 发明了 www 万维网 1992年，同事发明了 CSS 1993年，李爵士 创办了 W3C 1995年，网景 Netscape（公司） -&gt; Navigator（浏览器） 支持脚本，之前只支持 HTML + CSS JS 之父：Brendan Eich，JS 最初叫 Mocha -&gt; liveScript -&gt; JavaScript，10天完成了设计 网景和 Sun 公司（发明 java）达成协议，JS 和 Java 一起发布 此时 JS 还缺少很多模块，编码有问题，Unicode 在之后才发布了 UTF-8 1996，MS IE -&gt; JScript 网景 被打败，开源 -&gt; Firefox IE 5.5，MS 推出 JS 发请求功能 2004，Gmail 利用 JS 发请求功能，做了网页上的程序。JS 变成正式的编程语言 2010左右，中国 前端 Front-end 网景为了打败 MS，向 ECMA 申报标准 （ECMAScript） JS 不行：全局变量（没有模块化）、标准库（内置代码少） ECMAScript 4 死了，ECMAScript 5 做了小升级，步子太小 ES6：Rails 社区 Ruby —— CoffeeScript，JS 改良版。类，箭头函数 ES5 不兼容 IE7，ES 6 不兼容 IE8 二、7种数据类型 ECMAScript 的变量是松散类型的，所谓松散类型就是可以用来保存任何类型的数据。换句话说， 每个变量仅仅是一个用于保存值的占位符而已。 Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回”function”，而其他浏览器在这种情况下会返回 “object”。 1. Number 数字 .1 可表示 0.1； 0b 二进制，0o / 前导0 八进制，0x 十六进制 i. 浮点数值 带小数点，但实际上为整型的变量会保存为整型。 ECMASctipt 会将那些小数点后面带有 6 个零以上的浮点数值转换为以 e 表示法 表示的数值(例如，0.0000003 会被转换成 3e-7)。 浮点数值的最高精度是 17 位小数，但在进行算术计算时其精确度远远不如整数。例如，0.1 加 0.2 的结果不是 0.3，而是 0.30000000000000004。这个小小的舍入误差会导致无法测试特定的浮点数值。 我们测试的是两个数的和是不是等于 0.3。如果这两个数是 0.05 和 0.25，或者是 0.15 和 0.15 都不会有问题。而如前所述，如果这两个数是 0.1 和 0.2，那么测试将无法通过。因此，永远不 要测试某个特定的浮点数值。 关于浮点数值计算会产生舍入误差的问题，有一点需要明确:这是使用基于 IEEE754 数值的浮点计算的通病，ECMAScript 并非独此一家;其他使用相同数值格 式的语言也存在这个问题。 ii. 数值范围 ECMAScript 能够表示的最小数值保 存在 Number.MIN_VALUE 中——在大多数浏览器中，这个值是 5e-324。 能够表示的最大数值保存在 Number.MAX_VALUE 中——在大多数浏览器中，这个值是 1.7976931348623157e+308。 要想确定一个数值是不是有穷的(换句话说，是不是位于最 小和最大的数值之间)，可以使用 isFinite()函数。返 回 Boolean 值。 访问 Number.NEGATIVE_INFINITY 和 Number.POSITIVE_INFINITY 也可以 得到负和正 Infinity 的值。可以想见，这两个属性中分别保存着-Infinity 和 Infinity。 iii. NaN 在 ECMAScript 中，任何数值除以 0 会返回 NaN （但实际上只有 0 除以 0 才会返回 NaN，正数除以 0 返回 Infinity，负数除以 0 返回-Infinity。） NaN，即非数值(Not a Number)是一个特殊的数值 NaN 与任何值都不相等，包括 NaN 本身 isNaN()函数 ：判断是否为 NaN parseInt() 函数 var num1 = parseInt(“10”, 2); var num2 = parseInt(“10”, 8); var num3 = parseInt(“10”, 10); var num4 = parseInt(“10”, 16); //2 (按二进制解析) //8 (按八进制解析) //10(按十进制解析) //16(按十六进制解析) 2. String 字符串 空字符串 长度为0，空格字符串 长度为1； 转义：\ + xxx，\n 回车，\t Tab 制表符，长度为1 多行字符串（不是字符串里有回车）：123456789101112131415// 坑var s = &apos;1234 \ 5678&apos;// 推荐var s2 = &apos;1234&apos; + &apos;5678&apos;// 很多空格 会报错，因为没有闭合var s3 = &apos;1234 \______ 5678&apos;// ES6 特性 模板字符串包含回车 length: 9var s4 = `12346789` 3. Boolean 布尔 Boolean，数学家，下雨去上课没带伞，肺病死了。。。 if (&quot;222&quot;) { console.log(&#39;代码执行到此处&#39;) } 实际上打印的代码不会执行，MDN 对于宽松相等有表格总结，”222” -&gt; 222，true -&gt; 1，222 != 1；建议：（1）== 两端有 true 和 false，千万不要使用 == （2）== 两端有 []、&quot;&quot;，或者 0，尽量不要使用 == 4. Symbol(符号) Symbol 生成一个全局唯一的值。Symbol 的值和名字没有关系。 123var a1 = Symbol(&apos;a&apos;)var a2 = Symbol(&apos;a&apos;)a1 !== a2 // true 5. Null(对象) 要保存对象的变量还没真正保存对象，空对象指针 调用 typeof null 会返回”object” 6. Undefined(声明变量后没赋值 / 没有声明该变量) 未初始化的变量会自动被赋予 undefined 值，显式地初始化变化更为明智。如此在 typeof 操作符返回 ‘undefined’ 值时，可知道被检测变量还未被声明。 7. Object 对象 key 不加引号，要遵守标识符的规则: （1）不能数字开头；（2）不能有空格；（3）合法字符 key 符合标识符的情况下可用 obj.key，其余 obj[&#39;key&#39;] delete obj[&#39;key&#39;] 删除 key，obj[&#39;key&#39;] = undefined 只是将值置为 undefined typeof 操作符“undefined”——如果这个值未定义;“boolean”——如果这个值是布尔值;“number”——如果这个值是数值;“object”——如果这个值是对象或 null;“function”——如果这个值是函数。 // function 不在7种类型中 调用 typeof null 会返回”object”，因为特殊值 null 被认为是一个空的对象引用。 Safari 5 及之前版本、Chrome 7 及之 前版本在对正则表达式调用 typeof 操作符时会返回”function”，而其他浏览器在这种情况下会返回 “object”。]]></content>
      <tags>
        <tag>JS的历史</tag>
        <tag>JS数据类型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[算法初级 & 数据结构]]></title>
    <url>%2F2019%2F02%2F28%2F%E7%AE%97%E6%B3%95%E5%88%9D%E7%BA%A7%2F</url>
    <content type="text"><![CDATA[体育委员两两摸头法（冒泡排序）无序区两两比较，最大的放到有序区前端体育老师一指禅法（选择排序）找出最小的，放到最前起扑克牌法（插入排序）强迫症收扑克牌法（基数排序）快排归并排序堆排序排序可视化：https://visualgo.net/bn/sorting 数据结构哈希表（Hash Table） 计数排序中的桶（复杂度 O(n+max)，比快排还快 使用场景：如 年龄统计（最大值不能过大） 优点：速度快 缺点：（1）需要一个哈希作为计数工具；（2）无法对负数和小数进行排序。 桶排序 与计数排序的区别: 每个桶内放某个范围内的数字，每个桶内可再排序；比计数排序节省空间，浪费时间。 基数排序 与计数排序的区别：桶的个数的固定的，先比个位数，再比十位数，以此类推，适合大数字的排序。 队列（Queue）push / shift 先进先出 可以用数组实现 举例：排队 栈（Stack）push / pop 先进后出 可以用数组实现 举例：盗梦空间 链表（Linked List） 数组无法直接删除中间的一项，链表可以，但是要取到第N项则较麻烦 用哈希（JS里面用对象表示哈希）实现链表 head、node 概念 树（tree） 举例：层级结构、DOM 概念：层数、深度、节点个数 二叉树 满二叉树 完全二叉树 完全二叉树和满二叉树可以用数组实现 其他树可以用哈希（对象）实现 操作：增删改查 堆排序用到了 tree 其他：B树、红黑树、AVL树 堆排序可视化 &gt;&gt;堆排序JS代码完整讲解 &gt;&gt;]]></content>
      <tags>
        <tag>哈希</tag>
        <tag>队列</tag>
        <tag>栈</tag>
        <tag>链表</tag>
        <tag>树</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS_盒模型]]></title>
    <url>%2F2019%2F02%2F28%2FCSS-%E7%9B%92%E6%A8%A1%E5%9E%8B%2F</url>
    <content type="text"><![CDATA[一、基本概念IE模型：width/height 只包含content标准模型：width/height 包含content + padding + border 内联样式： 行内的 写在html的style标签内的。 外联样式：link引入的样式表。 二、JS如何设置盒模型对应的宽和高 dom.style.width/height: 只能获取内联样式，不够准确。 dom.currentStyle.width/height：浏览器渲染之后的样式，不管之前样式是怎么获取的，比较准确，但只有IE支持。 window.getComputedStyle(dom).width/height: 和上一个api原理相似，只不过可以兼容FireFox和chome。 dom.getBoundingClientRect().width/height: 这个api也可以获取准确的属性值，可以获取相对视窗的绝对位置（左上角），有4个属性： top left width height 三、边距重叠问题 取较大值 利用如下实例说明 12345678910111213141516//父级 height:100px; //子集 height：100px; 有 margin-top:10px;//且父级的背景色不显示&lt;section id="sec"&gt; &lt;style&gt; #sec&#123; background: red; &#125; .child&#123; height:100px; margin-top:10px; background:yellow; &#125; &lt;/style&gt; &lt;article class="child"&gt;&lt;/article&gt;&lt;/section&gt; 12345678910111213141516//父级高度变为 110px；// BFC(边距重叠解决方案)&lt;section id="sec"&gt; &lt;style&gt; #sec&#123; background: red; overflow: hidden; //增加该属性 &#125; .child&#123; height:100px; margin-top:10px; background:yellow; &#125; &lt;/style&gt; &lt;article class="child"&gt;&lt;/article&gt;&lt;/section&gt; BFC的概念：块级元素格式化上下文(相应的-IFC-内联元素格式化上下文) BFC的原理（渲染规则） 在BFC这个元素的垂直方向的边距会产生重叠 BFC的区域不会与浮动元素的box重叠（用来清除浮动） BFC在页面上是一个独立的容器，外面的元素不会影响它里面的元素，反之亦然 计算BFC高度时，浮动元素也会参与计算 如何创建BFC float值不为none； position的值不是static或relative； display值为table、table-cell等和table有关的，block, list-item； overflow值不为visible，即hidden、scroll、auto都可，inherit(从父元素继承 overflow属性的值,所以不确定，因为可能继承到visible) BFC的使用场景： 边距重叠：给元素添加一个父级，并给父级创建BFC。（测试发现直接对元素创建BFC不管用，还是需要父级） 浮动元素重叠：2个浮动的元素，高度固定，当其中一块的内容超出，该元素会与另一浮动元素重叠，++对高度超出的元素创建BFC++，可解决该问题 清除浮动：BFC子元素即使是float，也会参与高度计算。（例子：子元素浮动，高度为100px，在浏览器F12发现父级高度为0，原因是float脱离文档流，没有参与计算，当给父级创建BFC，BFC计算高度时，浮动元素也会参与计算，此时父级高度变为了100px；若子元素为文字，父级有背景色，在清除浮动后，父级的背景色才可见。这就是之前用overflow：hidden；清除浮动的原理） 扩展 float: left/right/none/inherit position: absolute: 绝对定位, 相对于 static 定位以外的第一个父元素进行定位。 fixed: 绝对定位, 相对于浏览器窗口进行定位。 relative: 相对定位, 相对于其正常位置进行定位。 static: 默认值。没有定位，元素出现在正常的流中。 inherit: 从父元素继承 position 属性的值。 overflow: visible: 默认值。内容不会被修剪，会呈现在元素框之外。 hidden: 内容会被修剪，并且其余内容是不可见的。 scroll: 内容会被修剪，但是浏览器会显示滚动条以便查看其余的内容。 auto: 如果内容被修剪，则浏览器会显示滚动条以便查看其余的内容。 inherit: 从父元素继承 overflow 属性的值。 display: 值 描述 none 此元素不会被显示。 block 此元素将显示为块级元素，此元素前后会带有换行符。 inline 默认。此元素会被显示为内联元素，元素前后没有换行符。 inline-block 行内块元素。（CSS2.1 新增的值）。 list-item 此元素会作为列表显示。 run-in 此元素会根据上下文作为块级元素或内联元素显示。 compact CSS中有值compact，不过由于缺乏广泛支持，已经从CSS2.1中删除。 marker CSS 中有值 marker，不过由于缺乏广泛支持，已经从 CSS2.1 中删除。 table 此元素会作为块级表格来显示（类似table），表格前后带有换行符。 inline-table 此元素会作为内联表格来显示（类似table），表格前后没有换行符。 table-row-group 此元素会作为一个或多个行的分组来显示（类似tbody）。 table-header-group 此元素会作为一个或多个行的分组来显示（类似thead）。 table-footer-group 此元素会作为一个或多个行的分组来显示（类似tfoot）。 table-row 此元素会作为一个表格行显示（类似 tr）。 table-column-group 此元素会作为一个或多个列的分组来显示（类似colgroup）。 table-column 此元素会作为一个单元格列显示（类似 col）。 table-cell 此元素会作为一个表格单元格显示（类似 td 和 th）。 table-caption 此元素会作为一个表格标题显示（类似 caption）。 inherit 规定应该从父元素继承 display 属性的值。]]></content>
      <tags>
        <tag>清除浮动的原理</tag>
        <tag>BFC</tag>
        <tag>JS获取宽高</tag>
        <tag>IE模型</tag>
        <tag>标准模型</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS_布局&小技巧]]></title>
    <url>%2F2019%2F02%2F28%2FCSS-%E5%B8%83%E5%B1%80-%E5%B0%8F%E6%8A%80%E5%B7%A7%2F</url>
    <content type="text"><![CDATA[左中右布局查看在线 demo （调整浏览器宽度见效果） 5种布局：float、绝对定位、flex、表格、网格 网格布局兼容性差，测试发现chome、FireFox新版本兼容，360浏览器grid挂了。 浮动-优点：兼容性高；缺点：浮动要清除，关系要处理好 绝对定位-优点：快捷；缺点：脱离文档流了，之后的元素也要脱离文档流，可使用性差 flex-css3出现，移动端，比较完美，不兼容IE8 表格-优点：兼容性好，缺点：三栏，其中一个单元格高度超出，别的单元格也会调整 网格-新技术-优点：代码量少，缺点：只兼容ie11+ 垂直布局查看在线 demo （调整浏览器高度见效果） 4种布局：绝对定位、flex、表格、网格 网格布局兼容性差，测试发现chome、FireFox新版本兼容，360浏览器grid挂了。 垂直方向与水平方向在编写是略有不同，需要设1234html, body, ...&#123; //省略号代表包含items的标签 height:100%; width:... //宽度自设&#125; 左右布局 (资料来自博客，抄抄大法好) 分类：2列定宽（不说了）、1列定宽、2列都自适应 左列定宽，右列自适应margin + float12345678&lt;div class="parent"&gt; &lt;div class="left"&gt;&lt;p&gt;left&lt;/p&gt;&lt;/div&gt; &lt;div class="right-fix"&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt;&lt;p&gt;right&lt;/p&gt; &lt;/div&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213141516.left &#123; float: left; //向左浮动 width: 100px; //固定宽度 position: relative; //由于.left与.right-fix重合，且.right-fix在DOM树上的位置比.left要后，因此.right-fix会遮挡住.left，设置.left为relative可以让其冒出来。&#125;.right-fix &#123; float: right; //向右浮动 width: 100%; //为了自适应设为100% margin-left: -100px; //由于宽度设为100%，.right-fix遭到浏览器换行处理；因此通过设置负的margin值，在左侧制造出100px的空白，使.right-fix与.left重合（即处于同一行）&#125;.right &#123; margin-left: 120px; //由于.left和.right-fix重合了，因此给.right设置一个margin-left，避免内容区（.right）与.left重合。另外，120px - 100px = 多出来的20px实际上就相当于.left和.right之间的间隔了。&#125; 这个方法其实已经是兼顾到低版本IE的完善版本了，缺点是代码冗长，而且有两个关键知识点比较难理解： 给.left加上position:relative;怎么就能让.left冒出来而不受.right-fix的遮挡了呢？ .right-fix设置负的margin-left，怎么就能使.left与.right-fix重合了呢？ 再者，这个方案由于.right-fix的margin-left和.left的width高度耦合，因此无法实现自适应，只能应用在左列（当然右列也成）固定宽度的场景。 absolute123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678910111213.parent&#123; position: relative;&#125;.left&#123; position: absolute; left: 0; width: 100px;&#125;.right&#123; position: absolute; left: 120px; //比.left的left多出20px，相当于间隔 right: 0;&#125; 这种方法是通过absolute配合left/right进行布局： 设置display: absolute后，通过top/right/bottom/left可以实现对元素的位置进行像素级的任意控制。因此，使用left属性即可控制各元素的起始位置，避免重叠。 自适应的关键在于left和right属性，在对元素同时设置这两个属性后，元素的宽度便会遭到拉伸，实现自适应。 需要注意的是父级元素需要设置display: relative。 这种方案很容易理解，但缺点就是不能做到“不定宽”，因为.left和.right的left属性的值高度相关。 左列不定宽，右列自适应float + BFC123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 12345678.left&#123; float: left; width: 100px; margin-right: 20px; //形成20px的间隔&#125;.right&#123; overflow: hidden; //通过设置overflow: hidden来触发BFC特性&#125; 这个方法主要是应用到BFC的一个特性： 浮动元素的块状兄弟元素会无视浮动元素的位置，尽量占满一整行，这样该兄弟元素就会被浮动元素覆盖。 若浮动元素的块状兄弟元素为BFC，则不会占满一整行，而是根据浮动元素的宽度，占据该行剩下的宽度，避免与浮动元素重叠。 浮动元素与其块状BFC兄弟元素之间的margin可以生效，这将继续减少兄弟元素的宽度。 并不是一定要在.right上用overflow: hidden;，只要能触发BFC就好了，另外在IE6上也可以触发haslayout特性（推荐用*zoom: 1;）。 由于.right的宽度是自动计算的，不需要设置任何与.left宽度相关的css，因此.left的宽度可以不固定（由内容盒子决定）。 table布局123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.parent&#123; display: table; width: 100%; table-layout: fixed;&#125;.left,.right&#123; display: table-cell;&#125;.left&#123; width: 100px; padding-right: 20px;&#125; 这个方法是表格布局的典型运用。说真的，我也很迷惘要不要使用表格布局，毕竟已经是上个时代的产物了，虽然已经不再用&lt;table&gt;的HTML结构了，但用上相应的CSS其实思路跟以前是变化不大的。 这个方法主要是利用了表格(table)的宽度必然等于其所有单元格(table-cell)加起来的总宽度，那么只要表格的宽度一定，其中一个（或几个）单元格的宽度也一定，那么另外一个未设置宽度的单元格则会默认占满剩下的宽度，即实现自适应。 flex123456789&lt;div class="parent"&gt; &lt;div class="left"&gt; &lt;p&gt;left&lt;/p&gt; &lt;/div&gt; &lt;div class="right"&gt; &lt;p&gt;right&lt;/p&gt; &lt;p&gt;right&lt;/p&gt; &lt;/div&gt;&lt;/div&gt; 1234567891011.parent&#123; display: flex;&#125;.left&#123; margin-right: 20px;&#125;.right&#123; flex: 1;&#125;.left p&#123;width: 200px;&#125; flex布局的自适应我就不多说了，本来就是设计来自适应的，只需要用上flex: 1;，就能让.right分到.parent的宽度减去.left的宽度。 推荐使用比较推荐用float + BFC方案，浏览器兼容性很好，代码量也少，另外也很好理解；移动端上也可以考虑用上flex方案，不过还是那一句，注意用旧版的flex，兼容性会好一点。 BFC 是什么？我失忆了，翻了下笔记详情见 &gt;&gt; CSS 盒模型 水平居中/垂直居中https://css-tricks.com/centering-css-complete-guide/ 文盲如何看懂英文，chrome 浏览器 翻译 其他小技巧 行内元素设置了 position：fixed/absolute 或者 float 属性，即脱离文档流，display 隐性更改为 inline-block 加了 display:inline-block;，元素底部多出间隙，加 vertical-align:top; 行内元素不能设置宽高，上下边距 所有的非空标签都有伪类（::before ::after） height 和width高度不要定死，容易出bug ionic 中用 position：fixed 容易变态 【译】22个必备的CSS小技巧 搞来抄一抄 https://codepen.io/pens/ Google]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[老博客]]></title>
    <url>%2F2019%2F02%2F27%2F%E8%80%81%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[源文件没了，只能痛哭流涕了 https://celesteweng.com/woshihuasheng.github.io/DOM事件类 https://celesteweng.com/woshihuasheng.github.io/2017/10/29/dom/CSS盒模型 https://celesteweng.com/woshihuasheng.github.io/2017/10/29/box/5种css自适应布局-垂直 https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-vertical/5种css自适应布局-水平 https://celesteweng.com/woshihuasheng.github.io/2017/10/26/CSS-horizontal/js整理4 https://celesteweng.com/woshihuasheng.github.io/2017/08/20/js整理4/js整理3 https://celesteweng.com/woshihuasheng.github.io/2017/08/17/js整理3/js整理2 https://celesteweng.com/woshihuasheng.github.io/2017/08/16/js整理2/js整理 https://celesteweng.com/woshihuasheng.github.io/2017/08/10/js整理/]]></content>
  </entry>
  <entry>
    <title><![CDATA[CSS笔记]]></title>
    <url>%2F2019%2F02%2F27%2FCSS%E7%AC%94%E8%AE%B0%2F</url>
    <content type="text"><![CDATA[文档流：文档内元素的流动方向。 内联元素：从左往右移动，如果遇到宽度不够，另起一行，继续流动。内联元素如果是个很长的单词，它是不会换行分开的，需设置 word-break: break-all;。break-word：在单词分割处中断。 块级元素：每一个块都占一行，每一个块从上往下依次流。 块级元素 高度：由其内部文档流元素 的高度 总和决定。 内联元素 高度：不同字体有不同的建议行高，行高可以改变内联元素高度。span 的 border 并不是内联元素的高度。 CSS 画三角形，可先把每个方向的 border 设置为不同颜色再慢慢试。]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS学习资源]]></title>
    <url>%2F2019%2F02%2F26%2FCSS%E5%AD%A6%E4%B9%A0%E8%B5%84%E6%BA%90%2F</url>
    <content type="text"><![CDATA[CSS 学习资源 Google: 关键词 MDN CSS Tricks Google: 阮一峰 css 张鑫旭的 240 多篇 CSS 博客 Codrops 炫酷 CSS 效果 CSS揭秘 CSS 2.1 中文 spec Magic of CSS 免费在线书 周边工具 LESS CSS 一种简化、功能更多的 CSS 语言 中文官网(Google: less css 中文官网) 英文官网(Google: less css) SASS 一种简化、功能更多的 CSS 语言（请自行搜索中英文官网） PostCSS 一种 CSS 处理程序 各种形状 https://css-tricks.com/the-shapes-of-css/ 生成渐变色 Google: CSS gradient generator 生成阴影 Google：CSS shadow generator]]></content>
      <tags>
        <tag>CSS</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTML标签]]></title>
    <url>%2F2019%2F02%2F25%2FHTML%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[iframe 标签嵌套页面 &lt;iframe src=&quot;https://www.baidu.com&quot; name=&quot;xxx&quot;&gt;&lt;/iframe&gt; name 属性可以和 a 标签配合使用 使用 frameborder=&quot;0&quot; 去掉元素边框 相当新开一个窗口，用起来卡 src 可以写相对路径 a 标签跳转页面（HTTP GET 请求） a 的更多属性见 &gt;&gt; MDN target 属性（结合 iframe 理解） _self：在当前页面打开（默认） _blank：在空页面打开 _partent：父框架集或父窗口打开 _top：祖宗窗口中打开 framename：在指定的 iframe 标签中打开 href 可以输入的内容 使用 http 协议或 https 协议：http://qq.com https://qq.com 使用和当前页面相同的协议，无协议绝对地址: //qq.com (直接预览为 file 协议，使用 http-server: npm i -g http-server, http-server or hs 可直接执行，http-server -c-1 不要缓存) 相对路径 (跳转到 /xxx.html)：xxx.html 锚点（不会发送请求，页面内跳转，别的都要发起请求）：#xxx 查询参数：?name=qqqq 伪协议：javascript:alert(1); （执行 js 代码）；javascript:;(需要写a标签，但是点击之后不需要跳转。直接写 href=&quot;#&quot; 会跳到页面顶部，href=&quot;&quot; 回刷新当前页，不写 href，a 标签变 span) 错误的： qq.com：为相对位置，当文件打开 download 属性：将链接变成可下载的。 另一方法：HTTP 响应头中设置 Content-Type: application/octet-stream，浏览器默认处理字节流的方式是下载 title 属性：规定额外信息，通常鼠标移到元素上显示这些信息。 form 标签跳转页面（HTTP POST 请求） form 的更多属性见 &gt;&gt; MDN 和 a 标签的区别是发起请求的类型不同。action 类似于 href，target 和 a标签的一样 GET 请求：表单信息变成查询参数，会出现在 url 里，请求头中无法有第四部分（Form Data）；POST 请求：表单信息作为 HTTP 请求的第四部分提交到服务器，如果要写查询参数，可直接写在 action 属性中， action=&quot;users?age=33&quot; method=”post”，默认为 get，自己改。 请求头中 Content-Type: application/x-www-form-urlencoded (key=value&amp;key=value，form 中 input 的 name 为 key) 提交的内容在 Form Data 中，HTTP 不靠谱，密码为明文。英文之外的都会转义，utf-8 变长编码，英文1个字节，中文3个字节，每个字节前有 % 如果 form 表单里没有提交按钮（input 标签，type=”submit”），则无法提交 如果1个 &lt;form&gt; 里面只有一个按钮(&lt;button&gt;)，会自动升级为提交按钮，但如果 button 标签写了 type=&quot;button&quot;，表单则无法提交 input input / button 区别：是否为「空标签」 input 的更多属性&gt;&gt;button 的更多属性&gt;&gt; type 说明 button 定义可点击按钮（多数情况下，用于通过 JavaScript 启动脚本）。和 button 标签在 form 表单中有区别，无法自动升级为提交按钮，看起来和 type=”submit” 的 input 一样 checkbox 定义复选框。（1） id=”xxx” &lt;label for=&quot;xxx&quot;&gt;你是白痴吗&lt;/label&gt;（2） 用label 包 input ，这样就不用 id 关联，老司机推荐&lt;label for=&quot;xxx&quot;&gt;你是白痴吗&lt;input type=&quot;checkbox&quot; name=&quot;user&quot;&gt;&lt;/label&gt;（3） 在 form 中，checked: inputName=on, !cheked: 无内容（4）多选，name 相同，value 不同，勾选的会被提交。如：name=”animal”, value=[“panda”, “dog”, “fish”] // 选了前两个，Form Data: animal=panda&amp;animal=fish file 定义输入字段和 “浏览”按钮，供文件上传。 hidden 定义隐藏的输入字段。https://blog.csdn.net/kuangruike/article/details/52127450 image 定义图像形式的提交按钮。 password 定义密码字段。该字段中的字符被掩码。只是在 html 看不见，实际上还是明文的 radio 定义单选按钮。similar to checkbox reset 定义重置按钮。重置按钮会清除表单中的所有数据。 submit 定义提交按钮。提交按钮会把表单数据发送到服务器。 text 定义单行的输入字段，用户可在其中输入文本。默认宽度为 20 个字符。 HTML5 新类型，不支持的浏览器显示为常规的文本域 email 要有 “@”，并且 “@” 前后都要有字符，且不能为中文（别的没试） url 粗糙测试，要有 http:// or https:// number 能够设定对所接受的数字的限定 min=”1” max=”10” range 滑动条，min max 设定范围，value 默认值，step 间隔 Date pickers (date, month, week, time, datetime, datetime-local) date - 选取日、月、年month - 选取月、年week - 选取周和年time - 选取时间（小时和分钟）datetime - 选取时间、日、月、年（UTC 时间）datetime-local - 选取时间、日、月、年（本地时间） search 右边多个叉叉，点了清空内容 color 只有 Opera 支持，应该没有卵用 select 标签下拉选择 123456789&lt;select name="group" multiple&gt; // multiple 可多选 &lt;option value=""&gt;-&lt;/option&gt; &lt;option value="1"&gt;item1&lt;/option&gt; &lt;option value="2"&gt;item2&lt;/option&gt; &lt;option value="3" disabled&gt;item3&lt;/option&gt; // disabled 不可选 &lt;option value="4" selected&gt;item4&lt;/option&gt; // selected 默认选中&lt;/select&gt;// 在 form 中提交格式为 selectName=selectedOptionValue textarea 标签输入多行内容 需求 操作 大小不可改变 CSS resize: none; 设置大小 (CSS width/height) or (col/rows 不准，一般不用) table 标签示例用于展示数据 input 的更多属性&gt;&gt; HTML 规定 &lt;table&gt; 中只可以有3个元素：&lt;thead&gt; &lt;tbody&gt; &lt;tfoot&gt; tbody 标签不写，浏览器会自动补上 表格边框的间隙默认有，不要则设置 table { border-collapse: collapse; } 123456789101112131415161718192021222324252627282930313233343536&lt;!-- table row 行 tr --&gt;&lt;!-- table data 数据 td --&gt;&lt;!-- table header 表头的标题 --&gt;&lt;table border=1&gt; &lt;!-- colgroup 里面有元素就是有标签的元素 --&gt; &lt;colgroup&gt; &lt;!-- col 指定列的宽度 --&gt; &lt;!-- col 有 bgcolor 属性，设置改列的背景色 --&gt; &lt;col width=100&gt; &lt;col bgcolor=red width=200&gt; &lt;col width=100&gt; &lt;col width=70&gt; &lt;/colgroup&gt; &lt;thead&gt; &lt;tr&gt; &lt;th&gt;项目&lt;/th&gt;&lt;th&gt;姓名&lt;/th&gt;&lt;th&gt;性别&lt;/th&gt;&lt;th&gt;年龄&lt;/th&gt; &lt;/tr&gt; &lt;/thead&gt; &lt;tbody&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;如花&lt;/td&gt;&lt;td&gt;1&lt;/td&gt;&lt;td&gt;90&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;&lt;/th&gt;&lt;td&gt;狗蛋&lt;/td&gt;&lt;td&gt;2&lt;/td&gt;&lt;td&gt;92&lt;/td&gt; &lt;/tr&gt; &lt;tr&gt; &lt;th&gt;平均分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tbody&gt; &lt;tfoot&gt; &lt;tr&gt; &lt;th&gt;总分&lt;/th&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt;&lt;td&gt;&lt;/td&gt; &lt;/tr&gt; &lt;/tfoot&gt;&lt;/table&gt; pre 标签 （preview）该标签中的文本，保留原有格式；&lt;pre&gt;标签中可以加标签 HTML5 新标签 完整列表&gt;&gt;]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是可替换标签(replaced element)]]></title>
    <url>%2F2019%2F02%2F25%2F%E4%BB%80%E4%B9%88%E6%98%AF%E5%8F%AF%E6%9B%BF%E6%8D%A2%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[定义可替换元素的展现效果不由 CSS 控制。这些元素是一种外部对象，它们外观的渲染，是独立于 CSS 的。 换句话说，它们的内容不受当前文档的样式的影响。CSS 可以影响可替换元素的位置，但不会影响到可替换元素自身的内容。某些可替换元素，例如 &lt;iframe&gt; 元素，可能具有自己的样式表，但它们不会继承父文档的样式。 CSS 能对可替换元素产生的唯一影响在于，部分属性支持控制元素内容在其框中的位置或定位方式。有关详细信息，请参阅本文下面的控制内容框中的对象位置。 可替换元素典型的可替换元素有： &lt;iframe&gt; &lt;video&gt; &lt;embed&gt; &lt;img&gt; 有些元素仅在特定情况下被作为可替换元素处理，例如： &lt;option&gt; &lt;audio&gt; &lt;canvas&gt; &lt;object&gt; &lt;applet&gt; HTML spec also says that an &lt;input&gt; element can be replaced, because &lt;input&gt; elements of the “image” type are replaced elements similar to &lt;img&gt;. However, other form controls, including other types of &lt;input&gt; elements, are explicitly listed as non-replaced elements (the spec describes their default platform-specific rendering with the term “Widgets”). Objects inserted using the CSS content property are anonymous replaced elements. They are “anonymous” because they don’t exist in the HTML markup. &lt;input&gt; 元素在 type 为 “image” 时为可替换标签，类似于 &lt;img&gt; 元素 使用 CSS 的 content 属性插入的对象是 匿名可替换元素，因为它们不是 HTML 标签，如：before、after 表示不知道 markup 是啥，搜了下 Markup is a symbol or character that you insert at certain place in a text file. This represents how the file should look (bold, italic, link, etc) when it is printed in your browser.Also the markup indicators are often called “tags.” HTML markup 俗称标签 CSS 与可替换元素CSS 在某些情况下会对可替换元素做一些特殊处理，比如计算外边距（margin）和一些 auto 的具体值。 需要注意的是，一部分（并非全部）可替换元素，其本身具有的尺寸和基线（baseline）会被一些 CSS 属性用到，加入计算之中，例如 vertical-align。会只有可替换元素才能具有这种自带值。 控制内容框中的对象位置某些CSS属性可用于指定被替换元素中包含的对象应如何定位在元素的框区域中。这些由CSS图像模块3级和CSS图像模块4级规范定义： object-fit Specifies how the replaced element’s content object should be fitted to the containing element’s box. object-position Specifies the alignment of the replaced element’s content object within the element’s box. 总结 典型的：&lt;iframe&gt;、&lt;video&gt;、&lt;embed&gt;、&lt;img&gt;，仅在特定情况下为可替换元素：&lt;option&gt;、&lt;audio&gt;、&lt;canvas&gt;、&lt;object&gt;、&lt;applet&gt;、&lt;input&gt;； 很多属性不受 CSS 控制； 使用 CSS 的 content 属性插入的对象是一个 anonymous replaced element（:before、:after）； CSS 对 replaced element 的一些计算会特殊处理，如 margin 和一些 auto 值； 有些（不是所有）的 replaced element 会有自己固有的尺寸，或用于 vertical-align 等属性的 baseline 「it is best to read “replaced” as “embedding”」这句话，很好地阐述了什么是 replaced element：它的内容是嵌入进来的。]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[什么是空标签（empty element）]]></title>
    <url>%2F2019%2F02%2F25%2F%E4%BB%80%E4%B9%88%E6%98%AF%E7%A9%BA%E6%A0%87%E7%AD%BE%2F</url>
    <content type="text"><![CDATA[定义 空元素是指来自 HTML，SVG 或 MathML 中，不具有任何子节点（即嵌套元素或文本节点）的元素。 HTML，SVG 和 MathML 的规范都详细定义了每个元素能包含的具体内容（define very precisely what each element can contain）。许多组合是没有任何语义含义的，比如一个 &lt;audio&gt; 元素嵌套在一个 &lt;hr&gt; 元素里。 在 HTML 中，通常在一个空元素上使用一个闭标签是无效的。例如， &lt;input type=&quot;text&quot;&gt;&lt;/input&gt; 的闭标签是无效的 HTML。 总结：不需要成对出现的标签 在 HTML 中有以下这些空元素 &lt;area&gt; &lt;base&gt; &lt;br&gt; &lt;col&gt; &lt;colgroup&gt; when the span is present &lt;command&gt; &lt;embed&gt; &lt;hr&gt; &lt;img&gt; &lt;input&gt; &lt;keygen&gt; （HTML 5.2 草案已删除） &lt;link&gt; &lt;meta&gt; &lt;param&gt; &lt;source&gt; &lt;track&gt; &lt;wbr&gt; Note: 在极少数情况下，空元素被错误地称为“无效元素”(void elements)。]]></content>
      <tags>
        <tag>HTML</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[HTTP]]></title>
    <url>%2F2019%2F02%2F24%2FHTTP%2F</url>
    <content type="text"><![CDATA[HTTP 请求请求示例命令 curl -s -v -H &quot;aaa: bbb&quot; -- &quot;https://www.baidu.com&quot; 请求的内容为 12345GET / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*aaa: bbb 命令 curl -X POST -d &quot;1234567890&quot; -s -v -H &quot;Celeste: xxx&quot; -- &quot;https://www.baidu.com&quot; 请求的内容为 123456789POST / HTTP/1.1Host: www.baidu.comUser-Agent: curl/7.54.0Accept: */*Celeste: xxxContent-Length: 10Content-Type: application/x-www-form-urlencoded1234567890 请求的格式1234567891 动词 路径 协议/版本2 Key1: value12 Key2: value22 Key3: value32 Content-Type: application/x-www-form-urlencoded2 Host: www.baidu.com2 User-Agent: curl/7.54.03 4 要上传的数据 请求最多包含四部分，最少包含三部分。（也就是说第四部分可以为空） 第三部分永远都是一个回车（\n） 动词有 GET POST PUT PATCH DELETE HEAD OPTIONS 等 这里的路径包括「查询参数」，但不包括「锚点」 如果你没有写路径，那么路径默认为 / 第 2 部分中的 Content-Type 标注了第 4 部分的格式 用 Chrome 发请求 打开 Network 地址栏输入网址 在 Network 点击，查看 request，点击「view source」 如果有请求的第四部分，那么在 FormData 或 Payload 里面可以看到 HTTP 响应响应示例123456789101112131415HTTP/1.1 200 OKAccept-Ranges: bytesCache-Control: private, no-cache, no-store, proxy-revalidate, no-transformConnection: Keep-AliveContent-Length: 2443Content-Type: text/htmlDate: Sun, 24 Feb 2019 05:55:32 GMTEtag: "58860421-98b"Last-Modified: Mon, 23 Jan 2017 13:24:49 GMTPragma: no-cacheServer: bfe/1.0.8.18Set-Cookie: BDORZ=27315; max-age=86400; domain=.baidu.com; path=/&lt;!DOCTYPE html&gt;&lt;!--STATUS OK--&gt;&lt;html&gt; &lt;head&gt; 省略 GET 请求和 POST 请求对应的响应可以一样，也可以不一样 响应的第四部分可以很长很长很长 响应的格式12345671 协议/版本号 状态码 状态解释2 Key1: value12 Key2: value22 Content-Length: 179312 Content-Type: text/html34 要下载的内容 状态码要背，是服务器对浏览器说的话 1xx 不常用 2xx 表示成功 3xx 表示滚吧 4xx 表示客户端出错 5xx 表示服务器出错 状态解释没什么用 第 2 部分中的 Content-Type 标注了第 4 部分的格式 第 2 部分中的 Content-Type 遵循 MIME 规范 用 Chrome 查看响应 打开 Network 输入网址 选中第一个响应 查看 Response Headers，点击「view source」 你会看到响应的前两部分 查看 Response 或者 Preview，你会看到响应的第 4 部分]]></content>
      <tags>
        <tag>HTTP</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git入门]]></title>
    <url>%2F2019%2F02%2F22%2Fgit%E5%85%A5%E9%97%A8%2F</url>
    <content type="text"><![CDATA[git init 运行”mkdir 目录名”，创建项目目录 运行”cd 目录名”，进入项目目录 运行”git init”，在当前工作目录创建一个空的 git 仓库，会生成一个 .git 隐藏目录 使用 tree 命令可以查看 .git 目录，其中 HEAD 为指向 master 的指针 git add 工作区的文件发生变化后，使用 git add 命令按需求添加到暂存区（index） 此时查看 .git 目录，相比执行完 git init 时，多了 index 文件，objects 目录也增加了 b1 子目录 大批量的操作文件时，可使用参数 -A -U，或 git add . git commit -v 当暂存区有内容时，执行该命令会进入 vim ，罗列未跟踪的文件和已提交的文件，同时展示已提交的文件相比之前的改动 执行过 git commit 命令后，.git 目录中会增加 COMMIT_EDITMSG 文件 git commit -m “提交信息” 可提交暂存区文件]]></content>
      <tags>
        <tag>命令行</tag>
        <tag>git</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[常用命令及查询]]></title>
    <url>%2F2019%2F02%2F21%2F%E5%B8%B8%E7%94%A8%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[lslist directory contents 罗列指定目录（或当前工作目录）中的子目录和文件 用法：ls [-alrtAFR] [name…] 参数 功能 -a 显示所有的文件，包括以”.”开头的隐藏文件 -l 不仅显示文件名，还罗列了文件型态、权限、所有者、文件大小、更新时间等信息 -r 将文件以相反次序显示(原定依英文字母次序) -t 将文件依建立时间之先后次序列出 -A 同 -a，但不列出 “.” (目前目录) 及 “..” (父目录) -F 在列出的文件名称后加一符号；例如可执行档则加 “*”, 目录则加 “/“ -R 若目录下有文件，则以下之文件亦皆依序列出 参数可叠加使用：ls -la 路径 cat concatenate files and print on the standard output 连接文件并打印到标准输出设备上 语法格式：cat [-AbeEnstTuv] [–help] [–version] fileName 参数 功能 -n 或 –number 由 1 开始对所有输出的行数编号 -b 或 –number-nonblank 和 -n 相似，只不过对于空白行不编号 -s 或 –squeeze-blank 当遇到有连续两行以上的空白行，就代换为一行的空白行 -v 或 –show-nonprinting 使用 ^ 和 M- 符号，除了 LFD 和 TAB 之外 -E 或 –show-ends 在每行结束处显示 $ -T 或 –show-tabs 将 TAB 字符显示为 ^I -A, –show-all 等价于 -vET -e 等价于”-vE”选项 -t 等价于”-vT”选项 mv move (rename) files 移动文件或目录到指定路径、重命名文件或目录 语法格式： mv [options] source dest mv [options] source… directory 命令格式 运行结果 mv 文件名 文件名 将源文件名改为指定文件名 mv 文件名 目录名 将文件移动到指定目录 mv 目录名 目录名 目标目录存在，将源目录移动到目标目录；目标目录不存在，源目录名改为指定目录名 mv 目录名 文件名 报错 touch change file timestamps 修改文件或目录的时间属性（读取时间、更改时间），文件不存在则创建一个新文件 语法格式：touch [-acfm][-d&lt;日期时间&gt;][-r&lt;参考文件或目录&gt;] [-t&lt;日期时间&gt;][–help][–version][文件或目录…] 这个参数感觉没什么卵用。。 如何使用 explainshell.com 把命令输进 input 查询，可以移动鼠标分别查看命令和参数的释义 点击结果中命令名，可以查看所有参数及其释义 点击命令名左侧向下箭头，可以切换查看命令在其他手册中的释义]]></content>
      <tags>
        <tag>命令行</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[对创建对象方法的理解]]></title>
    <url>%2F2019%2F01%2F24%2F%E5%AF%B9%E5%88%9B%E5%BB%BA%E5%AF%B9%E8%B1%A1%E6%96%B9%E6%B3%95%E7%9A%84%E7%90%86%E8%A7%A3%2F</url>
    <content type="text"><![CDATA[1. 创建 Object 对象的实例或通过对象字面量定义。缺点：大量重复代码。 2. 工厂模式123456789101112function createPerson(name, age, job)&#123; var o = new Object(); o.name = name; o.age = age; o.job = job; o.sayName = function()&#123; alert(this.name); &#125;; return o; &#125; var person1 = createPerson("Nicholas", 29, "Software Engineer");var person2 = createPerson("Greg", 27, "Doctor"); 解决了创建 多个相似对象的问题。在函数中定义对象，return 语句返回对象，通过调用函数创建对象。 缺点：书中说是无法识别对象的类型，但实际上创建出的对象变量可通过 constructor 属性判断（person1.constructor === Array），constructor 准确，instanceof 有误差 经试验，在函数中通过构造函数创建对象，则对象的 constructor 属性是准确的。如果是用 Object 构造函数创建，只有 obj instanceof Object 为 true；若是 Array 构造函数创建，不仅alert(obj instanceof Object); // true，同时alert(obj instanceof Array); // true 本人觉得工厂模式，硬是要判断也是可以判断的。书中的意思： 可能一：直接拿函数来判断，则无法判断函数内定义了哪种对象。 可能二：自定义的构造函数创建对象，对象即构造函数的实例，相当于这个对 象的类别就是自定义的构造函数，直观，同时也是 Object 的实例。 3. 构造函数模式12345678910function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; this.sayName = function()&#123; alert(this.name); &#125;; &#125; var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 和工厂模式的区别：没有显式地创建对象；直接将属性和方法赋给了 this 对象；没有 return 语句。 构造函数以大写字母开头 使用 new 操作符创建自定义构造函数的实例，经历的步骤：（1）创建一个新对象；（2）将构造函数的作用域赋给新对象（因此 this 就指向了这个新对象）；（3）执行构造函数中的代码（为这个新对象添加属性）；（4）返回新对象。 对象的 constructor（构造函数） 属性：最初用来标识对象类型，但还是 instanceof 操作符更为靠谱。在上例中创建的对象既是 Object 的实例，也是 Person 的实例。 将构造函数当做函数（1）使用 new 操作符当做构造函数使用；（2）作为普通函数调用：this 对象会只想 Global 对象；（3）在另一个对象的作用域中调用（改变 this 指向，apply\call） 构造函数的问题 1234567891011function Person(name, age, job)&#123; this.name = name; this.age = age; this.job = job; **this.sayName = sayName;**&#125; **function sayName()&#123; alert(this.name);&#125; **var person1 = new Person("Nicholas", 29, "Software Engineer");var person2 = new Person("Greg", 27, "Doctor"); 上述代码将函数定义在了构造函数外部，这样创建多个 Person 的实例时，就不会创建多个功能相同的 Function 实例了。 但是在全局作用域中定义的函数实际上只能被某个对象调用。更重要的是：如果对象需要定义很多方法，那就需要定义很多全局函数，没有封装性。-&gt; but，可通过使用原型模式解决。 构造函数模式个人小总结： 相对工厂模式，不显示地创建对象，使用 this 对象，同时没有 return 语句。解决了对象类别的识别问题。 可优化点：将对象的方法定义在全局，避免创建功能相同的 Function 的实例。但是在想要为对象添加很多方法时，就需要在全局声明很多函数，封装性不好。 缺点（将对象的方法声明在全局后，仍存在的问题）：全局函数实际上只能被某个对象调用。 4. 原型模式每个函数都有 prototype（原型）属性，该属性是一个指针，指向一个对象（原型对象），这个对象的用途是：包含 可以被 特定类型（本人理解：相当于构造函数，JS中没有类）的所有实例共享的属性和方法。 即在原型对象中定义对象实例的信息，而不必在构造函数中定义。 123456789101112function Person()&#123;&#125;Person.prototype.name = "Nicholas";Person.prototype.age = 29;Person.prototype.job = "Software Engineer";Person.prototype.sayName = function()&#123; alert(this.name);&#125;;var person1 = new Person();person1.sayName(); //"Nicholas"var person2 = new Person(); 原型模式个人小总结： 在函数的 prototype 属性中定义对象的属性和方法，可以被构造函数的实例共用。解决了构造函数模式 将 对象的方法声明在全局后，不能被多个实例共用的问题。]]></content>
      <tags>
        <tag>创建对象</tag>
        <tag>工厂模式</tag>
        <tag>构造函数模式</tag>
        <tag>原型模式</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[DOM事件类]]></title>
    <url>%2F2017%2F10%2F29%2Fdom%E4%BA%8B%E4%BB%B6%E7%B1%BB%2F</url>
    <content type="text"><![CDATA[一、基本概念：DOM事件的级别 事件级别（DOM标准定义的级别） DOM0 element.onclick = function(){} // 在 DOM1 标准产生之前就存在的事实规范 DOM2 element.addEventListener(‘click’,function(){},false) 默认false，冒泡；true为捕获。 DOM3 element.addEventListener(‘keyup’,function(){},false) DOM1标准并非不存在，只是没有涉及和事件相关的东西 二、DOM事件模型捕获：从上往下冒泡：从下往上 三、DOM事件流 浏览器为当前页面与用户做交互（如点击鼠标左键）的过程中，左键传到页面上，然后给出响应。 三个阶段 捕获 目标阶段：事件通过捕获到达目标元素（如：点击的那个按钮，就为目标阶段） 冒泡：从目标元素上传到window对象 四、描述DOM事件捕获的具体流程 接收事件的顺序 window document html(扩展：如何获取当前页面的html节点：document.documentElement) body … 最终：目标元素 冒泡则反向回去 五、Event对象的常见应用 简介：拿用户交互的参数，比如想知道按了哪个键，鼠标点了哪个键，基本都是从Event对象拿来的。 易混淆的5项： event.preventDefault() —- 阻止默认事件 event.stopPropagation() —- 阻止冒泡 event.stopImmediatePropagation() 例：一个按钮，绑定2个事件，响应函数a、响应函数b，通过++优先级++的方式，若a被点击，b不执行，就要用到该语句，在函数a中加入该语句。 event.currentTarget —-指向事件所绑定的元素（即事件委托中的父级） event.target —-始终指向事件发生时的元素 知识前提： 事件委托：把子元素的事件都委托到父元素上，绑定一次事件即可。做响应时，要判断当前是哪个元素被点击，就要用到target。 六、自定义事件12345var eve = new Event('custome');ev.addEventListener('custome', function()&#123; console.log('custome');&#125;);ev.ispatchEvent(eve); //触发eve对象 CustomEvent和Event区别：CustomEvent还可以绑定obj参数，在用法上，两者一致。 七、其他123function print()&#123; console.log('hi')&#125; 12onclick=&quot;要执行的代码&quot;一旦用户点击，浏览器就 `eval(&quot;要执行的代码&quot;)` 12xxx.onclick = print // 等号两边都为事件// 写为 print() 为 undefined 12345678xxx.onclick = function()&#123;&#125; // 属性，唯一，只能有一个点击事件// 队列，先进先出，可以监听多个点击事件function f1() &#123; console.log(1) // xxx.removeEventListener('click', f1()), one, 只执行一次&#125;xxx.addEventListener('click', f1()) 最后的子元素同时有捕获和冒泡，则看代码写的顺序执行；一般为先捕获，后冒泡。 用户有没有看当前页面(自动轮播时，bug，不看该页面时，定时器会偷懒) 123document.addEventListener('visbilitychange', function(e)&#123; console.log(document.hidden)&#125;)]]></content>
      <tags>
        <tag>DOM</tag>
      </tags>
  </entry>
</search>
